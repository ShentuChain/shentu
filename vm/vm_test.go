// Copyright Monax Industries Limited
// SPDX-License-Identifier: Apache-2.0

package vm

import (
	"bytes"
	"encoding/binary"
	"math/big"
	"reflect"
	"testing"
	"time"

	"github.com/hyperledger/burrow/acm"
	"github.com/hyperledger/burrow/acm/acmstate"
	. "github.com/hyperledger/burrow/binary"
	"github.com/hyperledger/burrow/crypto"
	"github.com/hyperledger/burrow/execution/engine"
	"github.com/hyperledger/burrow/execution/errors"
	"github.com/hyperledger/burrow/execution/evm/abi"
	. "github.com/hyperledger/burrow/execution/evm/asm"
	. "github.com/hyperledger/burrow/execution/evm/asm/bc"
	"github.com/hyperledger/burrow/execution/exec"
	"github.com/hyperledger/burrow/execution/native"
	"github.com/hyperledger/burrow/execution/solidity"
	"github.com/hyperledger/burrow/txs"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/tmthrgd/go-hex"
)

// Test output is a bit clearer if we /dev/null the logging, but can be re-enabled by uncommenting the below
//var logger, _, _ = lifecycle.NewStdErrLogger()

// testDDMP is a test version of wrappedDDMP to reduce raw output and test gas accordingly
func testDDMP(err errors.Sink) engine.Memory {
	return gasMemory{engine.NewDynamicMemory(0, 0x1000000, err), 0, 0}
}

// Runs a basic loop
func TestVM(t *testing.T) {
	vm := NewCVM(engine.Options{
		MemoryProvider: testDDMP,
		Natives:        native.MustDefaultNatives(),
	})

	t.Run("BasicLoop", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		// Create accounts
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")

		var gas uint64 = 400000 //TODO, why does gas need to be over twice the amount?
		// var gas uint64 = 100000

		bytecode := MustSplice(PUSH1, 0x00, PUSH1, 0x20, MSTORE, JUMPDEST, PUSH2, 0x0F, 0x0F, PUSH1, 0x20, MLOAD,
			SLT, ISZERO, PUSH1, 0x1D, JUMPI, PUSH1, 0x01, PUSH1, 0x20, MLOAD, ADD, PUSH1, 0x20,
			MSTORE, PUSH1, 0x05, JUMP, JUMPDEST)

		start := time.Now()
		output, err := vm.Execute(st, blockchain, eventSink, engine.CallParams{
			Caller: account1,
			Callee: account2,
			Gas:    big.NewInt(int64(gas)),
		}, bytecode)
		t.Logf("Output: %v Error: %v\n", output, err)
		t.Logf("Call took: %v", time.Since(start))
		require.NoError(t, err)
	})

	t.Run("SHL", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")

		var gas uint64 = 100000

		//Shift left 0
		bytecode := MustSplice(PUSH1, 0x01, PUSH1, 0x00, SHL, return1())
		output, err := call(vm, st, account1, account2, bytecode, nil, &gas)
		value := []byte{0x1}
		expected := LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift left 0
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SHL, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift left 1
		bytecode = MustSplice(PUSH1, 0x01, PUSH1, 0x01, SHL, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x2}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift left 1
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x01, SHL, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x2}
		expected = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift left 1
		bytecode = MustSplice(PUSH32, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x01, SHL, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift left 255
		bytecode = MustSplice(PUSH1, 0x01, PUSH1, 0xFF, SHL, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x80}
		expected = RightPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift left 255
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0xFF, SHL, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x80}
		expected = RightPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift left 256 (overflow)
		bytecode = MustSplice(PUSH1, 0x01, PUSH2, 0x01, 0x00, SHL, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x00}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift left 256 (overflow)
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH2, 0x01, 0x00, SHL,
			return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x00}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift left 257 (overflow)
		bytecode = MustSplice(PUSH1, 0x01, PUSH2, 0x01, 0x01, SHL, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x00}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}
	})

	t.Run("SHR", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")

		var gas uint64 = 100000

		//Shift right 0
		bytecode := MustSplice(PUSH1, 0x01, PUSH1, 0x00, SHR, return1())
		output, err := call(vm, st, account1, account2, bytecode, nil, &gas)
		value := []byte{0x1}
		expected := LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift right 0
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SHR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift right 1
		bytecode = MustSplice(PUSH1, 0x01, PUSH1, 0x01, SHR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x00}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift right 1
		bytecode = MustSplice(PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, PUSH1, 0x01, SHR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x40}
		expected = RightPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift right 1
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x01, SHR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []byte{0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift right 255
		bytecode = MustSplice(PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, PUSH1, 0xFF, SHR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x1}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift right 255
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0xFF, SHR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x1}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift right 256 (underflow)
		bytecode = MustSplice(PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, PUSH2, 0x01, 0x00, SHR,
			return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x00}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift right 256 (underflow)
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH2, 0x01, 0x00, SHR,
			return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x00}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift right 257 (underflow)
		bytecode = MustSplice(PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, PUSH2, 0x01, 0x01, SHR,
			return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x00}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}
	})

	t.Run("SAR", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")

		var gas uint64 = 100000

		//Shift arith right 0
		bytecode := MustSplice(PUSH1, 0x01, PUSH1, 0x00, SAR, return1())
		output, err := call(vm, st, account1, account2, bytecode, nil, &gas)
		value := []byte{0x1}
		expected := LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative arith shift right 0
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SAR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift arith right 1
		bytecode = MustSplice(PUSH1, 0x01, PUSH1, 0x01, SAR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x00}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift arith right 1
		bytecode = MustSplice(PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, PUSH1, 0x01, SAR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0xc0}
		expected = RightPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift arith right 1
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x01, SAR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift arith right 255
		bytecode = MustSplice(PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, PUSH1, 0xFF, SAR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift arith right 255
		bytecode = MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0xFF, SAR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift arith right 255
		bytecode = MustSplice(PUSH32, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0xFF, SAR, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []uint8([]byte{0x00})
		expected = RightPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift arith right 256 (reset)
		bytecode = MustSplice(PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, PUSH2, 0x01, 0x00, SAR,
			return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []uint8([]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF})

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Alternative shift arith right 256 (reset)
		bytecode = MustSplice(PUSH32, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH2, 0x01, 0x00, SAR,
			return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		value = []byte{0x00}
		expected = LeftPadBytes(value, 32)
		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}

		//Shift arith right 257 (reset)
		bytecode = MustSplice(PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, PUSH2, 0x01, 0x01, SAR,
			return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		expected = []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF}

		assert.Equal(t, expected, output)

		t.Logf("Result: %v == %v\n", output, expected)

		if err != nil {
			t.Fatal(err)
		}
	})

	//Test attempt to jump to bad destination (position 16)
	t.Run("JumpErr", func(t *testing.T) {
		st := acmstate.NewMemoryState()

		// Create accounts
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "2")

		var gas uint64 = 100000

		bytecode := MustSplice(PUSH1, 0x10, JUMP)

		var err error
		ch := make(chan struct{})
		go func() {
			_, err = call(vm, st, account1, account2, bytecode, nil, &gas)
			ch <- struct{}{}
		}()
		tick := time.NewTicker(time.Second * 2)
		select {
		case <-tick.C:
			t.Fatal("VM ended up in an infinite loop from bad jump dest (it took too long!)")
		case <-ch:
			if err == nil {
				t.Fatal("Expected invalid jump dest err")
			}
		}
	})

	// Tests the code for a subcurrency contract compiled by serpent
	t.Run("Subcurrency", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		// Create accounts
		account1 := newAccount(t, st, "1, 2, 3")
		account2 := newAccount(t, st, "3, 2, 1")

		// var gas uint64 = 1000
		var gas uint64 = 50000

		bytecode := MustSplice(PUSH3, 0x0F, 0x42, 0x40, CALLER, SSTORE, PUSH29, 0x01, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, PUSH1,
			0x00, CALLDATALOAD, DIV, PUSH4, 0x15, 0xCF, 0x26, 0x84, DUP2, EQ, ISZERO, PUSH2,
			0x00, 0x46, JUMPI, PUSH1, 0x04, CALLDATALOAD, PUSH1, 0x40, MSTORE, PUSH1, 0x40,
			MLOAD, SLOAD, PUSH1, 0x60, MSTORE, PUSH1, 0x20, PUSH1, 0x60, RETURN, JUMPDEST,
			PUSH4, 0x69, 0x32, 0x00, 0xCE, DUP2, EQ, ISZERO, PUSH2, 0x00, 0x87, JUMPI, PUSH1,
			0x04, CALLDATALOAD, PUSH1, 0x80, MSTORE, PUSH1, 0x24, CALLDATALOAD, PUSH1, 0xA0,
			MSTORE, CALLER, SLOAD, PUSH1, 0xC0, MSTORE, CALLER, PUSH1, 0xE0, MSTORE, PUSH1,
			0xA0, MLOAD, PUSH1, 0xC0, MLOAD, SLT, ISZERO, ISZERO, PUSH2, 0x00, 0x86, JUMPI,
			PUSH1, 0xA0, MLOAD, PUSH1, 0xC0, MLOAD, SUB, PUSH1, 0xE0, MLOAD, SSTORE, PUSH1,
			0xA0, MLOAD, PUSH1, 0x80, MLOAD, SLOAD, ADD, PUSH1, 0x80, MLOAD, SSTORE, JUMPDEST,
			JUMPDEST, POP, JUMPDEST, PUSH1, 0x00, PUSH1, 0x00, RETURN)

		data := hex.MustDecodeString("693200CE0000000000000000000000004B4363CDE27C2EB05E66357DB05BC5C88F850C1A0000000000000000000000000000000000000000000000000000000000000005")
		output, err := call(vm, st, account1, account2, bytecode, data, &gas)
		t.Logf("Output: %v Error: %v\n", output, err)
		if err != nil {
			t.Fatal(err)
		}
		require.NoError(t, err)
	})

	//This test case is taken from EIP-140 (https://github.com/ethereum/EIPs/blob/master/EIPS/eip-140.md);
	//it is meant to test the implementation of the REVERT opcode
	t.Run("Revert", func(t *testing.T) {
		st := acmstate.NewMemoryState()

		// Create accounts
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "1, 0, 1")

		key, value := []byte{0x00}, []byte{0x00}
		err := st.SetStorage(account1, LeftPadWord256(key), value)
		require.NoError(t, err)

		var gas uint64 = 100000

		bytecode := MustSplice(PUSH13, 0x72, 0x65, 0x76, 0x65, 0x72, 0x74, 0x65, 0x64, 0x20, 0x64, 0x61, 0x74, 0x61,
			PUSH1, 0x00, SSTORE, PUSH32, 0x72, 0x65, 0x76, 0x65, 0x72, 0x74, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			PUSH1, 0x00, MSTORE, PUSH1, 0x0E, PUSH1, 0x00, REVERT)

		/*bytecode := MustSplice(PUSH32, 0x72, 0x65, 0x76, 0x65, 0x72, 0x74, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61,
		0x67, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, PUSH1, 0x00, MSTORE, PUSH1, 0x0E, PUSH1, 0x00, REVERT)*/

		output, err := call(vm, st, account1, account2, bytecode, nil, &gas)
		assert.Error(t, err, "Expected execution reverted error")

		storageVal, err := st.GetStorage(account1, LeftPadWord256(key))
		require.NoError(t, err)
		assert.Equal(t, value, storageVal)

		t.Logf("Output: %v\n", output)
	})

	// Test sending tokens from a contract to another account
	t.Run("SendCall", func(t *testing.T) {
		st := acmstate.NewMemoryState()

		// Create accounts
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "2")
		account3 := newAccount(t, st, "3")

		// account1 will call account2 which will trigger CALL opcode to account3
		addr := account3
		contractCode := callContractCode(addr)

		//----------------------------------------------
		// account2 has insufficient balance, should fail
		txe := runVM(st, account1, account2, contractCode, 200000)
		exCalls := txe.ExceptionalCalls()
		require.Len(t, exCalls, 2)
		require.Equal(t, errors.Codes.InsufficientBalance, errors.GetCode(exCalls[0].Header.Exception))

		//----------------------------------------------
		// give account2 sufficient balance, should pass
		addToBalance(t, st, account2, 100000)

		txe = runVM(st, account1, account2, contractCode /* 1000 */, 1234567890)
		assert.Nil(t, txe.Exception, "Should have sufficient balance")

		//----------------------------------------------
		// insufficient gas, should fail
		txe = runVM(st, account1, account2, contractCode, 100)
		assert.NotNil(t, txe.Exception, "Expected insufficient gas error")
	})

	// Test to ensure that contracts called with STATICCALL cannot modify state
	// as per https://github.com/ethereum/EIPs/blob/master/EIPS/eip-214.md
	t.Run("StaticCallReadOnly", func(t *testing.T) {
		gas1, gas2 := /* byte(0x1) */ byte(0xff), byte(0x1)
		value := byte(0x69)
		var inOff, inSize, retOff, retSize byte

		logDefault := MustSplice(PUSH1, inSize, PUSH1, inOff)
		testRecipient := engine.AddressFromName("1")
		// check all illegal state modifications in child staticcall frame
		for _, illegalContractCode := range []acm.Bytecode{
			MustSplice(PUSH9, "arbitrary", PUSH1, 0x00, SSTORE),
			MustSplice(logDefault, LOG0),
			MustSplice(logDefault, PUSH1, 0x1, LOG1),
			MustSplice(logDefault, PUSH1, 0x1, PUSH1, 0x1, LOG2),
			MustSplice(logDefault, PUSH1, 0x1, PUSH1, 0x1, PUSH1, 0x1, LOG3),
			MustSplice(logDefault, PUSH1, 0x1, PUSH1, 0x1, PUSH1, 0x1, PUSH1, 0x1, LOG4),
			MustSplice(PUSH1, 0x0, PUSH1, 0x0, PUSH1, 0x69, CREATE),
			MustSplice(PUSH20, testRecipient, SELFDESTRUCT),
		} {
			// TODO: CREATE2

			t.Logf("Testing state-modifying bytecode: %v", illegalContractCode.MustTokens())
			st := acmstate.NewMemoryState()
			callee := makeAccountWithCode(t, st, "callee", MustSplice(illegalContractCode, PUSH1, 0x1, return1()))

			// equivalent to CALL, but enforce state immutability for children
			code := MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1, inOff,
				PUSH1, value, PUSH20, callee, PUSH2, gas1, gas2, STATICCALL, PUSH1, retSize,
				PUSH1, retOff, RETURN)
			caller := makeAccountWithCode(t, st, "caller", code)

			txe := runVM(st, caller, callee, code /*1000*/, 90000)
			_ = txe
			// the topmost caller can never *illegally* modify state

			require.Error(t, txe.Exception)
			require.Equal(t, errors.Codes.IllegalWrite, txe.Exception.ErrorCode(),
				"should get an error from child accounts that st is read only")
		}
	})

	t.Run("StaticCallWithValue", func(t *testing.T) {
		gas1, gas2 := /*byte(0x1)*/ byte(0xff), byte(0x1)
		value := byte(0x69)
		var inOff, inSize, retOff, retSize byte

		st := acmstate.NewMemoryState()

		finalAddress := makeAccountWithCode(t, st, "final", MustSplice(PUSH1, int64(20), return1()))

		// intermediate account CALLs another contract *with* a value
		callee := makeAccountWithCode(t, st, "callee", MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
			inOff, PUSH1, value, PUSH20, finalAddress, PUSH2, gas1, gas2, CALL, returnWord()))

		callerCode := MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
			inOff, PUSH1, value, PUSH20, callee, PUSH2, gas1, gas2, STATICCALL, PUSH1, retSize,
			PUSH1, retOff, RETURN)
		caller := makeAccountWithCode(t, st, "caller", callerCode)

		addToBalance(t, st, callee, 100000)
		txe := runVM(st, caller, callee, callerCode /*1000*/, 21400)
		_ = txe

		//TODO: Fix this test so that it does not fail due to gas repricing

		require.NotNil(t, txe.Exception)
		require.Equal(t, errors.Codes.IllegalWrite, txe.Exception.ErrorCode(),
			"expected static call violation because of call with value")

	})

	t.Run("StaticCallNoValue", func(t *testing.T) {
		gas1, gas2 := byte(0x1), byte(0x1)
		value := byte(0x69)
		var inOff, inSize, retOff, retSize byte

		// this final test just checks that STATICCALL actually works
		st := acmstate.NewMemoryState()

		finalAddress := makeAccountWithCode(t, st, "final", MustSplice(PUSH1, int64(20), return1()))
		// intermediate account CALLs another contract *without* a value
		callee := makeAccountWithCode(t, st, "callee", MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
			inOff, PUSH1, 0x00, PUSH20, finalAddress, PUSH2, gas1, gas2, CALL, returnWord()))

		callerCode := MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
			inOff, PUSH1, value, PUSH20, callee, PUSH2, gas1, gas2, STATICCALL, PUSH1, retSize,
			PUSH1, retOff, RETURN)
		caller := makeAccountWithCode(t, st, "caller", callerCode)

		addToBalance(t, st, callee, 100000)
		txe := runVM(st, caller, callee, callerCode, 1000)
		_ = txe
		/*
			TODO: Fix this test so that it does not fail due to gas repricing

			// no exceptions expected because value never set in children
			require.NoError(t, txe.Exception.AsError())
			exCalls := txe.ExceptionalCalls()
			require.Len(t, exCalls, 0)
		*/
	})

	// Test evm account creation
	t.Run("Create", func(t *testing.T) {
		st := acmstate.NewMemoryState()

		code := MustSplice(PUSH1, 0x0, PUSH1, 0x0, PUSH1, 0x0, CREATE, PUSH1, 0, MSTORE, PUSH1, 20, PUSH1, 12, RETURN)
		callee := makeAccountWithCode(t, st, "callee", code)
		// ensure pre-generated address has same sequence number
		nonce := make([]byte, txs.HashLength+uint64Length)
		binary.BigEndian.PutUint64(nonce[txs.HashLength:], 1)
		addr := crypto.NewContractAddress(callee, nonce)

		var gas uint64 = 100000
		caller := newAccount(t, st, "1, 2, 3")
		output, err := call(vm, st, caller, callee, code, nil, &gas)
		assert.NoError(t, err, "Should return new address without error")
		assert.Equal(t, addr.Bytes(), output, "Addresses should be equal")
	})

	// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1014.md
	t.Run("Create2", func(t *testing.T) {
		st := acmstate.NewMemoryState()

		// salt of 0s
		var salt [32]byte
		code := MustSplice(PUSH1, 0x0, PUSH1, 0x0, PUSH1, 0x0, PUSH32, salt[:], CREATE2, PUSH1, 0, MSTORE, PUSH1, 20, PUSH1, 12, RETURN)
		callee := makeAccountWithCode(t, st, "callee", code)
		addr := crypto.NewContractAddress2(callee, salt, code)

		var gas uint64 = 100000
		caller := newAccount(t, st, "1, 2, 3")
		output, err := call(vm, st, caller, callee, code, nil, &gas)
		assert.NoError(t, err, "Should return new address without error")
		assert.Equal(t, addr.Bytes(), output, "Returned value not equal to create2 address")
	})

	// This test was introduced to cover an issues exposed in our handling of the
	// gas limit passed from caller to callee on various forms of CALL.
	// The idea of this test is to implement a simple DelegateCall in EVM code
	// We first run the DELEGATECALL with _just_ enough gas expecting a simple return,
	// and then run it with 1 gas unit less, expecting a failure
	t.Run("DelegateCallGas", func(t *testing.T) {
		st := acmstate.NewMemoryState()

		inOff := 0
		inSize := 0 // no call data
		retOff := 0
		retSize := 32
		calleeReturnValue := int64(20)

		callee := makeAccountWithCode(t, st, "callee", MustSplice(PUSH1, calleeReturnValue, PUSH1, 0, MSTORE, PUSH1, 32, PUSH1, 0, RETURN))

		// 6 op codes total
		baseOpsCost := engine.GasBaseOp * 6
		// 4 pushes
		pushCost := engine.GasStackOp * 4
		// 2 pushes 2 pops
		returnCost := engine.GasStackOp * 4
		// To push success/failure
		resumeCost := engine.GasStackOp

		// Gas is not allowed to drop to 0 so we add resumecost
		delegateCallCost := baseOpsCost + pushCost + returnCost + resumeCost

		// Here we split up the caller code so we can make a DELEGATE call with
		// different amounts of gas. The value we sandwich in the middle is the amount
		// we subtract from the available gas (that the caller has available), so:
		// code := MustSplice(callerCodePrefix, <amount to subtract from GAS> , callerCodeSuffix)
		// gives us the code to make the call
		callerCodePrefix := MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize,
			PUSH1, inOff, PUSH20, callee, PUSH1)
		callerCodeSuffix := MustSplice(DELEGATECALL, returnWord())

		// Perform a delegate call
		//callerCode := MustSplice(callerCodePrefix,
		//	Give just enough gas to make the DELEGATECALL
		//delegateCallCost, callerCodeSuffix)
		//caller := makeAccountWithCode(t, st, "caller", callerCode)

		// Should pass
		//txe := runVM(st, caller, callee, callerCode, 100)
		//assert.Nil(t, txe.Exception, "Should have sufficient funds for call")
		//assert.Equal(t, Int64ToWord256(calleeReturnValue).Bytes(), txe.Result.Return)

		callerCode2 := MustSplice(callerCodePrefix,
			// Shouldn't be enough gas to make call
			delegateCallCost-1, callerCodeSuffix)
		caller2 := makeAccountWithCode(t, st, "caller2", callerCode2)

		// Should fail
		txe := runVM(st, caller2, callee, callerCode2, 100)
		assert.NotNil(t, txe.Exception, "Should have insufficient gas for call")
	})

	t.Run("MemoryBounds", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()
		vm := NewCVM(engine.Options{
			MemoryProvider: func(err errors.Sink) engine.Memory {
				return gasMemory{engine.NewDynamicMemory(1024, 2048, err), 0, 0}
			},
		})
		caller := makeAccountWithCode(t, st, "caller", nil)
		callee := makeAccountWithCode(t, st, "callee", nil)
		gas := uint64(1000000)
		word := One256
		// This attempts to store a value at the memory boundary and return it
		params := engine.CallParams{
			Gas:    big.NewInt(int64(gas)),
			Caller: caller,
			Callee: callee,
		}
		code := MustSplice(pushWord(word), storeAtEnd(), MLOAD, storeAtEnd(), returnAfterStore())

		output, err := vm.Execute(st, blockchain, eventSink, params, code)
		assert.NoError(t, err)
		assert.Equal(t, word.Bytes(), output)

		// Same with number
		word = Int64ToWord256(232234234432)
		code = MustSplice(pushWord(word), storeAtEnd(), MLOAD, storeAtEnd(), returnAfterStore())
		output, err = vm.Execute(st, blockchain, eventSink, params, code)
		assert.NoError(t, err)
		assert.Equal(t, word.Bytes(), output)

		// Now test a series of boundary stores
		code = pushWord(word)
		for i := 0; i < 10; i++ {
			code = MustSplice(code, storeAtEnd(), MLOAD)
		}
		code = MustSplice(code, storeAtEnd(), returnAfterStore())
		output, err = vm.Execute(st, blockchain, eventSink, params, code)
		assert.NoError(t, err)
		assert.Equal(t, word.Bytes(), output)

		// Same as above but we should breach the upper memory limit set in memoryProvider

		//	TODO: figure out why this doesn't work

		code = pushWord(word)
		for i := 0; i < 100; i++ {
			code = MustSplice(code, storeAtEnd(), MLOAD)
		}
		code = MustSplice(code, storeAtEnd(), returnAfterStore())
		_, err = vm.Execute(st, blockchain, eventSink, params, code)
		assert.Error(t, err, "Should hit memory out of bounds")

	})

	t.Run("MsgSender", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		account1 := newAccount(t, st, "1, 2, 3")
		account2 := newAccount(t, st, "3, 2, 1")
		var gas uint64 = 100000

		/*
				pragma solidity ^0.5.4;

				contract SimpleStorage {
			                function get() public constant returns (address) {
			        	        return msg.sender;
			    	        }
				}
		*/

		// This bytecode is compiled from Solidity contract above using remix.ethereum.org online compiler
		code := hex.MustDecodeString("6060604052341561000f57600080fd5b60ca8061001d6000396000f30060606040526004361060" +
			"3f576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680636d4ce63c14604457" +
			"5b600080fd5b3415604e57600080fd5b60546096565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ff" +
			"ffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6000339050905600a165627a" +
			"7a72305820b9ebf49535372094ae88f56d9ad18f2a79c146c8f56e7ef33b9402924045071e0029")

		var err error
		// Run the contract initialisation code to obtain the contract code that would be mounted at account2
		contractCode, err := call(vm, st, account1, account2, code, code, &gas)
		require.NoError(t, err)

		// Not needed for this test (since contract code is passed as argument to vm), but this is what an execution
		// framework must do
		err = engine.InitEVMCode(st, account2, contractCode)
		require.NoError(t, err)

		// Input is the function hash of `get()`
		input := hex.MustDecodeString("6d4ce63c")

		output, err := call(vm, st, account1, account2, contractCode, input, &gas)
		require.NoError(t, err)

		assert.Equal(t, account1.Word256().Bytes(), output)
	})

	t.Run("Invalid", func(t *testing.T) {
		st := acmstate.NewMemoryState()

		// Create accounts
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "1, 0, 1")

		var gas uint64 = 100000

		bytecode := MustSplice(PUSH32, 0x72, 0x65, 0x76, 0x65, 0x72, 0x74, 0x20, 0x6D, 0x65, 0x73, 0x73, 0x61,
			0x67, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, PUSH1, 0x00, MSTORE, PUSH1, 0x0E, PUSH1, 0x00, INVALID)

		output, err := call(vm, st, account1, account2, bytecode, nil, &gas)
		assert.Equal(t, errors.Codes.ExecutionAborted, errors.GetCode(err))
		t.Logf("Output: %v Error: %v\n", output, err)
	})

	t.Run("ReturnDataSize", func(t *testing.T) {
		st := acmstate.NewMemoryState()

		accountName := "account2addresstests"

		ret := "My return message"
		callcode := MustSplice(PUSH32, RightPadWord256([]byte(ret)), PUSH1, 0x00, MSTORE, PUSH1, len(ret), PUSH1, 0x00, RETURN)

		// Create accounts
		account1 := newAccount(t, st, "1")
		account2 := makeAccountWithCode(t, st, accountName, callcode)

		// var gas uint64 = 100000
		var gas uint64 = 123000

		gas1, gas2 := byte(0x1), byte(0x1)
		value := byte(0x69)
		inOff, inSize := byte(0x0), byte(0x0) // no call data
		retOff, retSize := byte(0x0), byte(len(ret))

		bytecode := MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1, inOff, PUSH1, value,
			PUSH20, account2, PUSH2, gas1, gas2, CALL,
			RETURNDATASIZE, PUSH1, 0x00, MSTORE, PUSH1, 0x20, PUSH1, 0x00, RETURN)

		expected := Uint64ToWord256(uint64(len(ret))).Bytes()

		output, err := call(vm, st, account1, account2, bytecode, nil, &gas)
		require.NoError(t, err)
		assert.Equal(t, expected, output)

		t.Logf("Output: %v Error: %v\n", output, err)

		if err != nil {
			t.Fatal(err)
		}
	})

	t.Run("ReturnDataCopy", func(t *testing.T) {
		st := acmstate.NewMemoryState()

		accountName := "account2addresstests"

		ret := "My return message"
		callcode := MustSplice(PUSH32, RightPadWord256([]byte(ret)), PUSH1, 0x00, MSTORE, PUSH1, len(ret), PUSH1, 0x00, RETURN)

		// Create accounts
		account1 := newAccount(t, st, "1")
		account2 := makeAccountWithCode(t, st, accountName, callcode)

		var gas uint64 = 100000

		gas1, gas2 := byte(0x1), byte(0x1)
		value := byte(0x69)
		inOff, inSize := byte(0x0), byte(0x0) // no call data
		retOff, retSize := byte(0x0), byte(len(ret))

		bytecode := MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1, inOff, PUSH1, value,
			PUSH20, account2, PUSH2, gas1, gas2, CALL, RETURNDATASIZE, PUSH1, 0x00, PUSH1, 0x00, RETURNDATACOPY,
			RETURNDATASIZE, PUSH1, 0x00, RETURN)

		expected := []byte(ret)

		output, err := call(vm, st, account1, account2, bytecode, nil, &gas)
		require.NoError(t, err)
		assert.Equal(t, expected, output)

		t.Logf("Output: %v Error: %v\n", output, err)
	})

	t.Run("CallNonExistent", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()
		account1 := newAccount(t, st, "1")
		addToBalance(t, st, account1, 100000)
		unknownAddress := engine.AddressFromName("nonexistent")
		var gas uint64
		amt := big.NewInt(100)
		params := engine.CallParams{
			Caller: account1,
			Callee: unknownAddress,
			Value:  *amt,
			Gas:    big.NewInt(int64(gas)),
		}
		_, ex := vm.Execute(st, blockchain, eventSink, params, nil)
		require.Equal(t, errors.Codes.NonExistentAccount, errors.GetCode(ex),
			"Should not be able to call account before creating it (even before initialising)")
		acc, err := st.GetAccount(unknownAddress)
		require.NoError(t, err)
		require.Nil(t, acc)
	})

	t.Run("GetBlockHash", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		// Create accounts
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")

		var gas uint64 = 100000

		bytecode := MustSplice(PUSH1, 2, BLOCKHASH)

		params := engine.CallParams{
			Caller: account1,
			Callee: account2,
			Gas:    big.NewInt(int64(gas)),
		}
		// Non existing block
		blockchain.blockHeight = 1
		_, err := vm.Execute(st, blockchain, eventSink, params, bytecode)
		require.Equal(t, errors.Codes.InvalidBlockNumber, errors.GetCode(err),
			"attempt to get block hash of a non-existent block")

		// Excessive old block
		blockchain.blockHeight = 258
		bytecode = MustSplice(PUSH1, 1, BLOCKHASH)

		_, err = vm.Execute(st, blockchain, eventSink, params, bytecode)
		require.Equal(t, errors.Codes.BlockNumberOutOfRange, errors.GetCode(err),
			"attempt to get block hash of a block outside of allowed range")

		// Get block hash
		blockchain.blockHeight = 257
		bytecode = MustSplice(PUSH1, 2, BLOCKHASH, return1())

		output, err := vm.Execute(st, blockchain, eventSink, params, bytecode)
		assert.NoError(t, err)
		assert.Equal(t, LeftPadWord256([]byte{2}), LeftPadWord256(output))

		// Get block hash fail
		blockchain.blockHeight = 3
		bytecode = MustSplice(PUSH1, 4, BLOCKHASH, return1())

		_, err = vm.Execute(st, blockchain, eventSink, params, bytecode)
		require.Equal(t, errors.Codes.InvalidBlockNumber, errors.GetCode(err),
			"attempt to get block hash failed")
	})

	t.Run("PushWord", func(t *testing.T) {
		word := Int64ToWord256(int64(2133213213))
		assert.Equal(t, MustSplice(PUSH4, 0x7F, 0x26, 0x40, 0x1D), pushWord(word))
		word[0] = 1
		assert.Equal(t, MustSplice(PUSH32,
			1, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0x7F, 0x26, 0x40, 0x1D), pushWord(word))
		assert.Equal(t, MustSplice(PUSH1, 0), pushWord(Word256{}))
		assert.Equal(t, MustSplice(PUSH1, 1), pushWord(Int64ToWord256(1)))
	})

	// Kind of indirect test of Splice, but here to avoid import cycles
	t.Run("Bytecode", func(t *testing.T) {
		assert.Equal(t,
			MustSplice(1, 2, 3, 4, 5, 6),
			MustSplice(1, 2, 3, MustSplice(4, 5, 6)))
		assert.Equal(t,
			MustSplice(1, 2, 3, 4, 5, 6, 7, 8),
			MustSplice(1, 2, 3, MustSplice(4, MustSplice(5), 6), 7, 8))
		assert.Equal(t,
			MustSplice(PUSH1, 2),
			MustSplice(byte(PUSH1), 0x02))
		assert.Equal(t,
			[]byte{},
			MustSplice(MustSplice(MustSplice())))

		contractAccount := &acm.Account{Address: crypto.AddressFromWord256(Int64ToWord256(102))}
		addr := contractAccount.Address
		gas1, gas2 := byte(0x1), byte(0x1)
		value := byte(0x69)
		inOff, inSize := byte(0x0), byte(0x0) // no call data
		retOff, retSize := byte(0x0), byte(0x20)
		contractCodeBytecode := MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
			inOff, PUSH1, value, PUSH20, addr, PUSH2, gas1, gas2, CALL, PUSH1, retSize,
			PUSH1, retOff, RETURN)
		contractCode := []byte{0x60, retSize, 0x60, retOff, 0x60, inSize, 0x60, inOff, 0x60, value, 0x73}
		contractCode = append(contractCode, addr[:]...)
		contractCode = append(contractCode, []byte{0x61, gas1, gas2, 0xf1, 0x60, 0x20, 0x60, 0x0, 0xf3}...)
		assert.Equal(t, contractCode, contractCodeBytecode)
	})

	t.Run("Concat", func(t *testing.T) {
		assert.Equal(t,
			[]byte{0x01, 0x02, 0x03, 0x04},
			Concat([]byte{0x01, 0x02}, []byte{0x03, 0x04}))
	})

	t.Run("Subslice", func(t *testing.T) {
		const size = 10
		data := make([]byte, size)
		for i := 0; i < size; i++ {
			data[i] = byte(i)
		}
		for n := uint64(0); n < size; n++ {
			data = data[:n]
			for offset := uint64(0); offset < size; offset++ {
				for length := uint64(0); length < size; length++ {
					_, err := subslice(data, offset, length)
					if offset < 0 || length < 0 || n < offset {
						assert.Error(t, err)
					} else {
						assert.NoError(t, err)
					}
				}
			}
		}

		bs, err := subslice([]byte{1, 2, 3, 4, 5, 6, 7, 8}, 4, 32)
		require.NoError(t, err)
		assert.Equal(t, []byte{
			5, 6, 7, 8, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
		}, bs)
	})

	t.Run("DataStackOverflow", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()
		account1 := newAccount(t, st, "1, 2, 3")
		account2 := newAccount(t, st, "3, 2, 1")

		var gas uint64 = 100000
		/*
			pragma solidity ^0.5.4;

			contract SimpleStorage {
				function get() public constant returns (address) {
					return get();
				}
			}
		*/

		// This bytecode is compiled from Solidity contract above using remix.ethereum.org online compiler
		code, err := hex.DecodeString("608060405234801561001057600080fd5b5060d18061001f6000396000f300608060405260043610" +
			"603f576000357c0100000000000000000000000000000000000000000000000000000000900463ff" +
			"ffffff1680636d4ce63c146044575b600080fd5b348015604f57600080fd5b5060566098565b6040" +
			"51808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffff" +
			"ffffffffffff16815260200191505060405180910390f35b600060a06098565b9050905600a16562" +
			"7a7a72305820daacfba0c21afacb5b67f26bc8021de63eaa560db82f98357d4e513f3249cf350029")
		require.NoError(t, err)

		// Run the contract initialisation code to obtain the contract code that would be mounted at account2
		params := engine.CallParams{
			Caller: account1,
			Callee: account2,
			Input:  code,
			Gas:    big.NewInt(int64(gas)),
		}
		vm := NewCVM(engine.Options{
			DebugOpcodes:      true,
			DataStackMaxDepth: 10, //4, TODO why does this need to change
		})

		code, err = vm.Execute(st, blockchain, eventSink, params, code)
		require.NoError(t, err)

		// Input is the function hash of `get()`
		params.Input, err = hex.DecodeString("6d4ce63c")
		require.NoError(t, err)

		_, ex := vm.Execute(st, blockchain, eventSink, params, code)
		require.Equal(t, errors.Codes.DataStackOverflow, errors.GetCode(ex), "Should be stack overflow")

	})

	t.Run("CallStackOverflow", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()
		txe := new(exec.TxExecution)

		account1 := newAccount(t, st, "1, 2, 3")
		account2 := newAccount(t, st, "3, 2, 1")

		// Sender accepts lot of gaz but we run on a caped call stack node
		var gas uint64 = 100000
		/*
			pragma solidity ^0.5.4;

			contract A {
			   function callMeBack() public {
					return require(msg.sender.call(bytes4(keccak256("callMeBack()")),this));
				}
			}
		*/

		// This bytecode is compiled from Solidity contract above using remix.ethereum.org online compiler
		code, err := hex.DecodeString("608060405234801561001057600080fd5b5061017a806100206000396000f3006080604052600436" +
			"10610041576000357c01000000000000000000000000000000000000000000000000000000009004" +
			"63ffffffff168063692c3b7c14610046575b600080fd5b34801561005257600080fd5b5061005b61" +
			"005d565b005b3373ffffffffffffffffffffffffffffffffffffffff1660405180807f63616c6c4d" +
			"654261636b28290000000000000000000000000000000000000000815250600c0190506040518091" +
			"0390207c010000000000000000000000000000000000000000000000000000000090043060405182" +
			"63ffffffff167c010000000000000000000000000000000000000000000000000000000002815260" +
			"0401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffff" +
			"ffffffffffffff1681526020019150506000604051808303816000875af192505050151561014c57" +
			"600080fd5b5600a165627a7a723058209315a40abb8b23b7c2a340e938b01367b419a23818475a2e" +
			"ee80d09da3f7ba780029")
		require.NoError(t, err)

		params := engine.CallParams{
			Caller: account1,
			Callee: account2,
			Input:  code,
			Gas:    big.NewInt(int64(gas)),
		}
		options := engine.Options{
			CallStackMaxDepth: 2,
		}
		vm := NewCVM(options)
		// Run the contract initialisation code to obtain the contract code that would be mounted at account2
		contractCode, err := vm.Execute(st, blockchain, eventSink, params, code)
		require.NoError(t, err)

		err = engine.InitEVMCode(st, account1, contractCode)
		require.NoError(t, err)
		err = engine.InitEVMCode(st, account2, contractCode)
		require.NoError(t, err)

		// keccak256 hash of 'callMeBack()'
		params.Input, err = hex.DecodeString("692c3b7c")
		require.NoError(t, err)

		_, err = vm.Execute(st, blockchain, txe, params, contractCode)
		// The TxExecution must be an exception to get the callerror
		txe.PushError(err)
		require.Error(t, err)
		callError := txe.CallError()
		require.Error(t, callError)
		require.Equal(t, errors.Codes.CallStackOverflow, errors.GetCode(callError))
		// Errors are post-order so first is deepest
		require.True(t, len(callError.NestedErrors) > 0)
		deepestErr := callError.NestedErrors[0]
		require.Equal(t, errors.Codes.CallStackOverflow, errors.GetCode(deepestErr))
		assert.Equal(t, options.CallStackMaxDepth, deepestErr.StackDepth)
		assert.Equal(t, account2, deepestErr.Callee)
		assert.Equal(t, account1, deepestErr.Caller)
	})

	t.Run("ExtCodeHash", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")

		var gas uint64 = 100000

		// The EXTCODEHASH of the account without code is c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470
		//    what is the keccack256 hash of empty data.
		bytecode := MustSplice(PUSH20, account1, EXTCODEHASH, return1())
		output, err := call(vm, st, account1, account2, bytecode, nil, &gas)
		assert.NoError(t, err)
		assert.Equal(t, hex.MustDecodeString("c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"), output)

		// The EXTCODEHASH of a native account is hash of its name.
		bytecode = MustSplice(PUSH1, 0x03, EXTCODEHASH, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		assert.NoError(t, err)
		assert.Equal(t, crypto.Keccak256([]byte("ripemd160Func")), output)

		// EXTCODEHASH of non-existent account should be 0
		bytecode = MustSplice(PUSH1, 0xff, EXTCODEHASH, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		assert.NoError(t, err)
		assert.Equal(t, Zero256[:], output)

		// EXTCODEHASH is the hash of an account code
		acc := makeAccountWithCode(t, st, "trustedCode", MustSplice(BLOCKHASH, return1()))
		bytecode = MustSplice(PUSH20, acc, EXTCODEHASH, return1())
		output, err = call(vm, st, account1, account2, bytecode, nil, &gas)
		assert.NoError(t, err)
		assert.Equal(t, hex.MustDecodeString("010da270094b5199d3e54f89afe4c66cdd658dd8111a41998714227e14e171bd"), output)
	})

	// Tests logs and events.
	t.Run("TestLogEvents", func(t *testing.T) {
		expectedData := []byte{0x10}
		expectedHeight := uint64(0)
		expectedTopics := []Word256{
			Int64ToWord256(1),
			Int64ToWord256(2),
			Int64ToWord256(3),
			Int64ToWord256(4)}

		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		// Create accounts
		address1 := crypto.Address{1, 3, 5, 7, 9}
		address2 := crypto.Address{2, 4, 6, 8, 10}

		err := engine.CreateAccount(st, address1)
		require.NoError(t, err)
		err = engine.CreateAccount(st, address2)
		require.NoError(t, err)

		var gas uint64 = 100000

		mstore8 := byte(MSTORE8)
		push1 := byte(PUSH1)
		log4 := byte(LOG4)
		stop := byte(STOP)

		code := []byte{
			push1, 16, // data value
			push1, 0, // memory slot
			mstore8,
			push1, 4, // topic 4
			push1, 3, // topic 3
			push1, 2, // topic 2
			push1, 1, // topic 1
			push1, 1, // size of data
			push1, 0, // data starts at this offset
			log4,
			stop,
		}

		txe := new(exec.TxExecution)

		params := engine.CallParams{
			Caller: address1,
			Callee: address2,
			Gas:    big.NewInt(int64(gas)),
		}
		_, err = vm.Execute(st, blockchain, txe, params, code)
		require.NoError(t, err)

		for _, ev := range txe.Events {
			if ev.Log != nil {
				if !reflect.DeepEqual(ev.Log.Topics, expectedTopics) {
					t.Errorf("Event topics are wrong. Got: %v. Expected: %v", ev.Log.Topics, expectedTopics)
				}
				if !bytes.Equal(ev.Log.Data, expectedData) {
					t.Errorf("Event data is wrong. Got: %s. Expected: %s", ev.Log.Data, expectedData)
				}
				if ev.Header.Height != expectedHeight {
					t.Errorf("Event block height is wrong. Got: %d. Expected: %d", ev.Header.Height, expectedHeight)
				}
				return
			}
		}
		t.Fatalf("Did not see LogEvent")
	})

	t.Run("BigModExp", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")

		// The solidity compiled contract. It calls bigmodexp with b,e,m inputs and compares the result with proof, where m is the mod, b the base, e the exp, and proof the expected result.
		bytecode := solidity.DeployedBytecode_BigMod

		// The function "expmod" is an assertion. It takes the base, exponent, modulus, and the expected value and
		// returns 1 if the values match.
		spec, err := abi.ReadSpec(solidity.Abi_BigMod)
		require.NoError(t, err)

		expModFunctionID := spec.Functions["expmod"].FunctionID

		n := int64(10)
		for base := -n; base < n; base++ {
			for exp := -n; exp < n; exp++ {
				for mod := int64(1); mod < n; mod++ {
					b := big.NewInt(base)
					e := big.NewInt(exp)
					m := big.NewInt(mod)
					v := new(big.Int).Exp(b, e, m)
					if v == nil {
						continue
					}

					input := MustSplice(expModFunctionID, // expmod function
						BigIntToWord256(b), BigIntToWord256(e), BigIntToWord256(m), // base^exp % mod
						BigIntToWord256(v)) // == expected

					gas := uint64(10000000)
					out, err := call(vm, st, account1, account2, bytecode, input, &gas)

					require.NoError(t, err)

					require.Equal(t, One256, LeftPadWord256(out), "expected %d^%d mod %d == %d",
						base, exp, mod, e)
				}
			}
		}
	})

	t.Run("Arithmetic tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 100000

		tests := []struct {
			name     string
			bytecode []byte
			expected []byte
		}{
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01"
				"add0",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, ADD, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE},
			},
			{
				// "code": "0x60047fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01"
				"add1",
				MustSplice(PUSH1, 0x04, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, ADD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
			},
			{
				// "code": "0x6000600001"
				"add2",
				MustSplice(PUSH1, 0x00, PUSH1, 0x00, ADD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x60026002600108"
				"addmod0",
				MustSplice(PUSH1, 0x02, PUSH1, 0x02, PUSH1, 0x01, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x60026002600003600160000308"
				"addmod1",
				MustSplice(PUSH1, 0x02, PUSH1, 0x02, PUSH1, 0x00, SUB, PUSH1, 0x01, PUSH1, 0x00, SUB, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x60036001600660000308"
				"addmod2",
				MustSplice(PUSH1, 0x03, PUSH1, 0x01, PUSH1, 0x06, PUSH1, 0x00, SUB, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// "code": "0x60036000036001600408"
				"addmod3",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x01, PUSH1, 0x04, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05},
			},
			{
				// "code": "0x60056000600160000308"
				"addmod4",
				MustSplice(PUSH1, 0x05, PUSH1, 0x00, PUSH1, 0x01, PUSH1, 0x00, SUB, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x60056001600160000308"
				"addmod5",
				MustSplice(PUSH1, 0x05, PUSH1, 0x01, PUSH1, 0x01, PUSH1, 0x00, SUB, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x60056002600003600160000308"
				"addmod6",
				MustSplice(PUSH1, 0x05, PUSH1, 0x02, PUSH1, 0x00, SUB, PUSH1, 0x01, PUSH1, 0x00, SUB, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04},
			},
			{
				// "code": "0x60036001600660000308600360056000030714"
				"addmod7",
				MustSplice(PUSH1, 0x03, PUSH1, 0x01, PUSH1, 0x06, PUSH1, 0x00, SUB, ADDMOD,
					PUSH1, 0x03, PUSH1, 0x05, PUSH1, 0x00, SUB, SMOD, EQ, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x60036001600660000308600360056000030614"
				"addmod8",
				MustSplice(PUSH1, 0x03, PUSH1, 0x01, PUSH1, 0x06, PUSH1, 0x00, SUB, ADDMOD,
					PUSH1, 0x03, PUSH1, 0x05, PUSH1, 0x00, SUB, MOD, EQ, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x60036000036001600408600055"
				"addmod9",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x01, PUSH1, 0x04, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05},
			},
			{
				// "code": "0x600560017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff08"
				"addmod10",
				MustSplice(PUSH1, 0x05, PUSH1, 0x01,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x60006001600008"
				"addmod11",
				MustSplice(PUSH1, 0x00, PUSH1, 0x01, PUSH1, 0x00, ADDMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "(asm 0x2 0xfedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210 DIV 0 MSTORE 32 0 RETURN)"
				"div0",
				MustSplice(PUSH32, 0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
					0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
					0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
					0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10, PUSH1, 0x02, DIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (/ 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBA 0x1DAE6076B981DAE6076B981DAE6076B981DAE6076B981DAE6076B981DAE6077)
				"div1",
				MustSplice(PUSH32, 0x01, 0xDA, 0xE6, 0x07, 0x6B, 0x98, 0x1D, 0xAE,
					0x60, 0x76, 0xB9, 0x81, 0xDA, 0xE6, 0x07, 0x6B,
					0x98, 0x1D, 0xAE, 0x60, 0x76, 0xB9, 0x81, 0xDA,
					0xE6, 0x07, 0x6B, 0x98, 0x1D, 0xAE, 0x60, 0x77,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, DIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89},
			},
			{
				// (/ 5 2)
				"div2",
				MustSplice(PUSH1, 0x02, PUSH1, 0x05, DIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// (/ 23 24)
				"div3",
				MustSplice(PUSH1, 0x18, PUSH1, 0x17, DIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (/ 0 24)
				"div4",
				MustSplice(PUSH1, 0x00, PUSH1, 0x18, DIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (/ 1 1)
				"div5",
				MustSplice(PUSH1, 0x01, PUSH1, 0x01, DIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (/ 2 0)
				"div6",
				MustSplice(PUSH1, 0x00, PUSH1, 0x02, DIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (+ (/ 13 0) 7)
				"div7",
				MustSplice(PUSH1, 0x07, PUSH1, 0x00, PUSH1, 0x0D, DIV, ADD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07},
			},
			{
				// (EXP 2 2)
				"exp0",
				MustSplice(PUSH1, 0x02, PUSH1, 0x02, EXP, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04},
			},
			{
				// (EXP 0 2147483647)
				"exp1",
				MustSplice(PUSH4, 0x7F, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, EXP, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (EXP 1 2147483647)
				"exp2",
				MustSplice(PUSH4, 0x7F, 0xFF, 0xFF, 0xFF, PUSH1, 0x01, EXP, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (EXP 2147483647 0)
				"exp3",
				MustSplice(PUSH1, 0x00, PUSH4, 0x7F, 0xFF, 0xFF, 0xFF, EXP, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (EXP 2147483647 1)
				"exp4",
				MustSplice(PUSH1, 0x01, PUSH4, 0x7F, 0xFF, 0xFF, 0xFF, EXP, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x7F, 0xFF, 0xFF, 0xFF},
			},
			{
				// (EXP 2 257)
				"exp5",
				MustSplice(PUSH2, 0x01, 0x01, PUSH1, 0x10, EXP, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (EXP 0 0)
				"exp6",
				MustSplice(PUSH1, 0x00, PUSH1, 0x00, EXP, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (EXP 256 31)
				"exp7",
				MustSplice(PUSH1, 0x1F, PUSH2, 0x01, 0x00, EXP, return1()),
				[]byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (EXP 255 31)
				"exp8",
				MustSplice(PUSH1, 0x1F, PUSH1, 0xFF, EXP, return1()),
				[]byte{0x00, 0xE2, 0xBF, 0xE9, 0x5C, 0x5D, 0x70, 0x67,
					0x56, 0x74, 0x02, 0xDD, 0x9D, 0x72, 0x35, 0xFC,
					0x08, 0x8A, 0xC8, 0x4E, 0xAB, 0x81, 0x13, 0xBF,
					0x8D, 0x7E, 0x3C, 0x28, 0x8D, 0x2F, 0x1E, 0xFF},
			},
			{
				// (EXP 257 31)
				"exp9",
				MustSplice(PUSH1, 0x1F, PUSH2, 0x01, 0x01, EXP, return1()),
				[]byte{0x01, 0x20, 0xE3, 0x0C, 0x8C, 0x1B, 0xB2, 0x5C,
					0x9D, 0x22, 0x19, 0xEA, 0x19, 0x6C, 0x17, 0xDE,
					0xD3, 0xD7, 0x75, 0xB2, 0x31, 0xBB, 0xD2, 0x80,
					0x05, 0xB1, 0x31, 0xFA, 0x90, 0xD1, 0x1F, 0x01},
			},
			{
				// (EXP 256 32)
				"exp10",
				MustSplice(PUSH1, 0x20, PUSH2, 0x01, 0x00, EXP, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (EXP 257 32)
				"exp11",
				MustSplice(PUSH1, 0x20, PUSH2, 0x01, 0x01, EXP, return1()),
				[]byte{0x22, 0x03, 0xEF, 0x98, 0xA7, 0xCE, 0x0E, 0xF9,
					0xBF, 0x3C, 0x04, 0x03, 0x85, 0x83, 0xF6, 0xB2,
					0xAB, 0x4D, 0x27, 0xE3, 0xED, 0x8E, 0x52, 0x85,
					0xB6, 0xE3, 0x2C, 0x8B, 0x61, 0xF0, 0x20, 0x01},
			},
			{
				// (% 2 3 )
				"mod0",
				MustSplice(PUSH1, 0x03, PUSH1, 0x02, MOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// (% 115792089237316195423570985008687907853269984665640564039457584007913129639935 2 )
				"mod1",
				MustSplice(PUSH1, 0x02,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, MOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (% 0 115792089237316195423570985008687907853269984665640564039457584007913129639935 )
				"mod2",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH1, 0x00, MOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (% 3 0)
				"mod3",
				MustSplice(PUSH1, 0x00, PUSH1, 0x03, MOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (% (- 0 2) 3)
				"mod4",
				MustSplice(PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x00, SUB, MOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// (* 2 3)
				"mul0",
				MustSplice(PUSH1, 0x03, PUSH1, 0x02, MUL, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06},
			},
			{
				// (* 115792089237316195423570985008687907853269984665640564039457584007913129639935 115792089237316195423570985008687907853269984665640564039457584007913129639935)
				"mul1",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, MUL, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (* 0 23)
				"mul2",
				MustSplice(PUSH1, 0x00, PUSH1, 0x17, MUL, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (* 23 1)
				"mul3",
				MustSplice(PUSH1, 0x01, PUSH1, 0x17, MUL, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17},
			},
			{
				// (* 0x8000000000000000000000000000000000000000000000000000000000000000 115792089237316195423570985008687907853269984665640564039457584007913129639935)
				"mul4",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MUL, return1()),
				[]byte{0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (* 0x8000000000000000000000000000000000000000000000000000000000000000 0x8000000000000000000000000000000000000000000000000000000000000000)
				"mul5",
				MustSplice(PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					PUSH32, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MUL, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (MULMOD 1 2 2)
				"mulmod0",
				MustSplice(PUSH1, 0x02, PUSH1, 0x02, PUSH1, 0x01, MULMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (MULMOD (- 0 1) (- 0 2) 3)
				"mulmod1",
				MustSplice(PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x00, SUB, PUSH1, 0x01, PUSH1, 0x00, SUB, MULMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (MULMOD (- 0 1) 2 5)
				"mulmod2",
				MustSplice(PUSH1, 0x05, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x00, SUB, MULMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (MULMOD (- 0 5) 1 3)
				"mulmod3",
				MustSplice(PUSH1, 0x03, PUSH1, 0x01, PUSH1, 0x05, PUSH1, 0x00, SUB, MULMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// (EQ (SMOD (- 0 5) 3) (MULMOD (- 0 5) 1 3) )
				"mulmod4",
				MustSplice(PUSH1, 0x03, PUSH1, 0x01, PUSH1, 0x05, PUSH1, 0x00, SUB, MULMOD,
					PUSH1, 0x03, PUSH1, 0x05, PUSH1, 0x00, SUB, SMOD, EQ, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (EQ (MOD (- 0 5) 3) (MULMOD (- 0 5) 1 3) )
				"mulmod5",
				MustSplice(PUSH1, 0x03, PUSH1, 0x01, PUSH1, 0x05, PUSH1, 0x00, SUB, MULMOD,
					PUSH1, 0x03, PUSH1, 0x05, PUSH1, 0x00, SUB, MOD, EQ, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (MULMOD 5 1 (- 0 3) )
				"mulmod6",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x01, PUSH1, 0x05, MULMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05},
			},
			{
				// (MULMOD 0 0 0)
				"mulmod7",
				MustSplice(PUSH1, 0x00, PUSH1, 0x00, PUSH1, 0x00, MULMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (MULMOD 5 1 0)
				"mulmod8",
				MustSplice(PUSH1, 0x05, PUSH1, 0x01, PUSH1, 0x00, MULMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (SDIV (- 0 115792089237316195423570985008687907853269984665640564039457584007913129639935) 115792089237316195423570985008687907853269984665640564039457584007913129639935)
				"sdiv0",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SUB, SDIV, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// (SDIV 115792089237316195423570985008687907853269984665640564039457584007913129639935 (- 0 115792089237316195423570985008687907853269984665640564039457584007913129639935) )
				"sdiv1",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH1, 0x00, SUB, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, SDIV, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// (SDIV 7 3 )
				"sdiv2",
				MustSplice(PUSH1, 0x03, PUSH1, 0x07, SDIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// (SDIV 7 (- 0 3) )
				"sdiv3",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x07, SDIV, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE},
			},
			{
				// (SDIV (- 0 7) 3 )
				"sdiv4",
				MustSplice(PUSH1, 0x03, PUSH1, 0x07, PUSH1, 0x00, SUB, SDIV, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE},
			},
			{
				// (SDIV (- 0 7) (- 0 3) )
				"sdiv5",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x07, PUSH1, 0x00, SUB, SDIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// (SDIV (- 0 1) 0 )
				"sdiv6",
				MustSplice(PUSH1, 0x00, PUSH1, 0x01, PUSH1, 0x00, SUB, SDIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (SDIV (- 0 1) 25 )
				"sdiv7",
				MustSplice(PUSH1, 0x25, PUSH1, 0x01, PUSH1, 0x00, SUB, SDIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (SDIV (- 0 1) 1 )
				"sdiv7",
				MustSplice(PUSH1, 0x01, PUSH1, 0x01, PUSH1, 0x00, SUB, SDIV, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// (SDIV (- 0 1) (- 0 1) )
				"sdiv8",
				MustSplice(PUSH1, 0x01, PUSH1, 0x00, SUB, PUSH1, 0x01, PUSH1, 0x00, SUB, SDIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (SDIV 115792089237316195423570985008687907853269984665640564039457584007913129639935 (- 0 57896044618658097711785492504343953926634992332820282019728792003956564819967) )
				"sdiv9",
				MustSplice(PUSH32, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH1, 0x00, SUB, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, SDIV, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (SDIV (- 0 57896044618658097711785492504343953926634992332820282019728792003956564819967) (- 0 1) )
				"sdiv10",
				MustSplice(PUSH1, 0x01, PUSH1, 0x00, SUB,
					PUSH32, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH1, 0x00, SUB, SDIV, return1()),
				[]byte{0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// "code": "0x62126af460500b600055"
				"signextend0",
				MustSplice(PUSH3, 0x12, 0x6A, 0xF4, PUSH1, 0x50, SIGNEXTEND, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x12, 0x6A, 0xF4},
			},
			{
				// (SIGNEXTEND 0 0)
				"signextend1",
				MustSplice(PUSH1, 0x00, PUSH1, 0x00, SIGNEXTEND, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (SIGNEXTEND 0 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
				"signextend2",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SIGNEXTEND, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// "code": "0x62122f6a60000b600055"
				"signextend3",
				MustSplice(PUSH3, 0x12, 0x2F, 0x6A, PUSH1, 0x00, SIGNEXTEND, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6A},
			},
			{
				// "code": "0x62126af460010b600055"
				"signextend4",
				MustSplice(PUSH3, 0x12, 0x6A, 0xF4, PUSH1, 0x01, SIGNEXTEND, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6A, 0xF4},
			},
			{
				// "code": "0x6212faf460010b600055"
				"signextend5",
				MustSplice(PUSH3, 0x12, 0xFA, 0xF4, PUSH1, 0x01, SIGNEXTEND, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFA, 0xF4},
			},
			{
				// "code": "0x62122ff460000b600055"
				"signextend6",
				MustSplice(PUSH3, 0x12, 0x2F, 0xF4, PUSH1, 0x00, SIGNEXTEND, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4},
			},
			{
				// "code": "0x66f000000000000161ffff0b600055"
				"signextend7",
				MustSplice(PUSH7, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, PUSH2, 0xFF, 0xFF, SIGNEXTEND, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (SIGNEXTEND 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe)
				"signextend8",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, SIGNEXTEND, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE},
			},
			{
				// (SIGNEXTEND 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)
				"signextend9",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, SIGNEXTEND, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// "code": "0x60ff68f000000000000000010b600055"
				"signextend10",
				MustSplice(PUSH1, 0xFF, PUSH9, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, SIGNEXTEND, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
			},
			{
				// (SMOD (- 0 5) (- 0 3))
				"smod0",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x05, PUSH1, 0x00, SUB, SMOD, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE},
			},
			{
				// (SMOD 5 (- 0 3))
				"smod1",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x05, SMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// (SMOD (- 0 5) 3)
				"smod2",
				MustSplice(PUSH1, 0x03, PUSH1, 0x05, PUSH1, 0x00, SUB, SMOD, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE},
			},
			{
				// ((SMOD (- 0 2) 115792089237316195423570985008687907853269984665640564039457584007913129639935))
				"smod3",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x02, PUSH1, 0x00, SUB, SMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// ((SMOD (- 0 2) 0))
				"smod4",
				MustSplice(PUSH1, 0x00, PUSH1, 0x02, PUSH1, 0x00, SUB, SMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// ((SMOD 0 (- 0 2)))
				"smod5",
				MustSplice(PUSH1, 0x02, PUSH1, 0x00, SUB, PUSH1, 0x00, SMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (SMOD (- 0 57896044618658097711785492504343953926634992332820282019728792003956564819967) 57896044618658097711785492504343953926634992332820282019728792003956564819967)
				"smod6",
				MustSplice(PUSH32, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SUB, SMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (SMOD (- 0 57896044618658097711785492504343953926634992332820282019728792003956564819967) 115792089237316195423570985008687907853269984665640564039457584007913129639935)
				"smod7",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SUB, SMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (SMOD (- 0 57896044618658097711785492504343953926634992332820282019728792003956564819968) (- 0 1) )
				"smod8",
				MustSplice(PUSH1, 0x01, PUSH1, 0x01, SUB, PUSH32, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SUB, SMOD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// (- 23 1)
				"sub0",
				MustSplice(PUSH1, 0x01, PUSH1, 0x17, SUB, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16},
			},
			{
				// (- 2 3)
				"sub1",
				MustSplice(PUSH1, 0x03, PUSH1, 0x02, SUB, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// (- 0 23)
				"sub2",
				MustSplice(PUSH1, 0x17, PUSH1, 0x00, SUB, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE9},
			},
			{
				// (- 0 115792089237316195423570985008687907853269984665640564039457584007913129639935)
				"sub3",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SUB, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// (- 0 115792089237316195423570985008687907853269984665640564039457584007913129639935)
				"sub4",
				MustSplice(PUSH1, 0x00, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, SUB, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
		}
		for _, tt := range tests {
			params := engine.CallParams{
				Caller: account1,
				Callee: account2,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); err != nil || !bytes.Equal(output, tt.expected) {
				t.Errorf("Reported error in %v.", tt.name)
				assert.NoError(t, err)
				assert.Equal(t, tt.expected, output)
			}
		}
	})

	t.Run("Bitwise logic operation tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 100000

		tests := []struct {
			name     string
			bytecode []byte
			expected []byte
		}{
			{
				// "code": "0x6002600216"
				"and0",
				MustSplice(PUSH1, 0x02, PUSH1, 0x02, AND, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// "code": "0x6001600216"
				"and1",
				MustSplice(PUSH1, 0x01, PUSH1, 0x02, AND, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x6001600316"
				"and2",
				MustSplice(PUSH1, 0x01, PUSH1, 0x03, AND, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x7f0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff16"
				"and3",
				MustSplice(PUSH32, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, AND, return1()),
				[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF},
			},
			{
				// "code": "0x6780402010080402016000601f031a"
				"byte0",
				MustSplice(PUSH8, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, PUSH1, 0x00, PUSH1, 0x1F, SUB, BYTE, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x6780402010080402016001601f031a"
				"byte1",
				MustSplice(PUSH8, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, PUSH1, 0x01, PUSH1, 0x1F, SUB, BYTE, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// "code": "0x6780402010080402016002601f031a"
				"byte2",
				MustSplice(PUSH8, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, PUSH1, 0x02, PUSH1, 0x1F, SUB, BYTE, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04},
			},
			{
				// "code": "0x6780402010080402016007601f031a"
				"byte3",
				MustSplice(PUSH8, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, PUSH1, 0x07, PUSH1, 0x1F, SUB, BYTE, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80},
			},
			{
				// "code": "0x678040201008040201601f601f031a"
				"byte4",
				MustSplice(PUSH8, 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01, PUSH1, 0x1F, PUSH1, 0x1F, SUB, BYTE, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x641234523456601f1a8001"
				"byte5",
				MustSplice(PUSH5, 0x12, 0x34, 0x52, 0x34, 0x56, PUSH1, 0x1F, BYTE, DUP1, ADD, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC},
			},
			{
				// "code": "0x6003600003600560000314"
				"eq0",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x05, PUSH1, 0x00, SUB, EQ, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x6000600014"
				"eq1",
				MustSplice(PUSH1, 0x00, PUSH1, 0x00, EQ, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff14"
				"eq2",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, EQ, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x6000600260000311"
				"gt0",
				MustSplice(PUSH1, 0x00, PUSH1, 0x02, PUSH1, 0x00, SUB, GT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x6002600003600011"
				"gt1",
				MustSplice(PUSH1, 0x02, PUSH1, 0x00, SUB, PUSH1, 0x01, GT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff11"
				"gt2",
				MustSplice(PUSH1, 0x00, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, GT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600011"
				"gt3",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, GT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff15"
				"iszero0",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, ISZERO, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x600015"
				"iszero1",
				MustSplice(PUSH1, 0x00, ISZERO, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x600260000315"
				"iszero2",
				MustSplice(PUSH1, 0x02, PUSH1, 0x00, SUB, ISZERO, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x6000600260000310"
				"lt0",
				MustSplice(PUSH1, 0x00, PUSH1, 0x02, PUSH1, 0x00, SUB, LT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x6002600003600010"
				"lt1",
				MustSplice(PUSH1, 0x02, PUSH1, 0x00, SUB, PUSH1, 0x00, LT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff10"
				"lt2",
				MustSplice(PUSH1, 0x00, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, LT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600010"
				"lt3",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, LT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x600019"
				"not0",
				MustSplice(PUSH1, 0x00, NOT, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// "code": "0x600219"
				"not1",
				MustSplice(PUSH1, 0x02, NOT, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19"
				"not2",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, NOT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x600260000319"
				"not2",
				MustSplice(PUSH1, 0x02, PUSH1, 0x00, SUB, NOT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60000319"
				"not3",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SUB, NOT, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE},
			},
			{
				// "code": "0x600060000319"
				"not4",
				MustSplice(PUSH1, 0x00, PUSH1, 0x00, SUB, NOT, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// "code": "0x6002600217"
				"or0",
				MustSplice(PUSH1, 0x02, PUSH1, 0x02, OR, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// "code": "0x6001600217"
				"or1",
				MustSplice(PUSH1, 0x01, PUSH1, 0x02, OR, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
			},
			{
				// "code": "0x6001600317"
				"or2",
				MustSplice(PUSH1, 0x01, PUSH1, 0x03, OR, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
			},
			{
				// "code": "0x7f0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff17"
				"or3",
				MustSplice(PUSH32, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, OR, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7feeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee17"
				"or4",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, OR, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7feeeeeeeeeeeeeeeeeeeeeeeeeeeeefeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee17"
				"or5",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEF, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, OR, return1()),
				[]byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
			},
			{
				// "code": "0x6000600260000313"
				"sgt0",
				MustSplice(PUSH1, 0x00, PUSH1, 0x02, PUSH1, 0x00, SUB, SGT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x6002600003600013"
				"sgt1",
				MustSplice(PUSH1, 0x02, PUSH1, 0x00, SUB, PUSH1, 0x00, SGT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff13"
				"sgt2",
				MustSplice(PUSH1, 0x00, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, SGT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600013"
				"sgt3",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SGT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x6003600003600560000313"
				"sgt4",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x05, PUSH1, 0x00, SUB, SGT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x6000600260000312"
				"slt0",
				MustSplice(PUSH1, 0x00, PUSH1, 0x02, PUSH1, 0x00, SUB, SLT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x6002600003600012"
				"slt1",
				MustSplice(PUSH1, 0x02, PUSH1, 0x00, SUB, PUSH1, 0x00, SLT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff12"
				"slt2",
				MustSplice(PUSH1, 0x00, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, SLT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600012"
				"slt3",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, SLT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x6003600003600560000312"
				"slt4",
				MustSplice(PUSH1, 0x03, PUSH1, 0x00, SUB, PUSH1, 0x05, PUSH1, 0x00, SUB, SLT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x6002600218"
				"xor0",
				MustSplice(PUSH1, 0x02, PUSH1, 0x02, XOR, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x6001600218"
				"xor1",
				MustSplice(PUSH1, 0x01, PUSH1, 0x02, XOR, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
			},
			{
				// "code": "0x6001600318"
				"xor2",
				MustSplice(PUSH1, 0x01, PUSH1, 0x03, XOR, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
			},
			{
				// "code": "0x7f0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff18"
				"xor3",
				MustSplice(PUSH32, 0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
					PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, XOR, return1()),
				[]byte{0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
					0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
					0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10,
					0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7feeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee18"
				"xor3",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, XOR, return1()),
				[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
					0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
					0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
					0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11},
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7feeeeeeeeeeeeeeeeeeeeeeeeeeeeefeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee18"
				"xor3",
				MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH32, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEF, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,
					0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, XOR, return1()),
				[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
					0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x10, 0x11,
					0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
					0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11},
			},
		}
		for _, tt := range tests {
			params := engine.CallParams{
				Caller: account1,
				Callee: account2,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); err != nil || !bytes.Equal(output, tt.expected) {
				t.Errorf("Reported error in %v.", tt.name)
				assert.NoError(t, err)
				assert.Equal(t, tt.expected, output)
			}
		}
	})

	t.Run("Block info tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 100000

		blockchain.blockHeight = 1

		tests := []struct {
			name     string
			bytecode []byte
			expected []byte
		}{
			{
				// "code": "0x41"
				"coinbase",
				MustSplice(COINBASE, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
			},
			{
				// "code": "0x42"
				"timestamp",
				MustSplice(TIMESTAMP, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0xFF, 0xFF, 0xFF, 0xF1, 0x88, 0x6E, 0x09, 0x00},
			},
			{
				// "code": "0x43"
				"blockheight",
				MustSplice(BLOCKHEIGHT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x44"
				"difficulty",
				MustSplice(DIFFICULTY, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x60004513"
				"gaslimit0",
				MustSplice(PUSH1, 0x00, GASLIMIT, SGT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
			{
				// "code": "0x620186A04512"
				"gaslimit1",
				MustSplice(PUSH3, 0x01, 0x86, 0xA0, GASLIMIT, SLT, return1()),
				[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
			},
		}
		for _, tt := range tests {
			params := engine.CallParams{
				Caller: account1,
				Callee: account2,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); err != nil || !bytes.Equal(output, tt.expected) {
				t.Errorf("Reported error in %v.", tt.name)
				assert.NoError(t, err)
				assert.Equal(t, tt.expected, output)
			}
		}
	})

	t.Run("Environmental info tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 100000

		tests := []struct {
			name         string
			origin       crypto.Address
			input        []byte
			value        uint64
			bytecode     []byte
			expected_out []byte
			expected_err *errors.Code
		}{
			{
				// "code": "0x30"
				name:     "address",
				bytecode: MustSplice(ADDRESS, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0xCE, 0x55, 0xAD, 0x3F,
					0xDC, 0x76, 0x1D, 0xE7, 0x34, 0x5D, 0x7B, 0x00,
					0x47, 0x78, 0xE9, 0x3B, 0x9D, 0x22, 0x2A, 0xE5},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60026001600037600051"
				name: "calldatacopy0",
				input: []byte{0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0x0A, 0xBC, 0xDE, 0xF0},
				bytecode: MustSplice(PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x00, CALLDATACOPY, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x34, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60026001600037600051600055596000f3"
				name: "calldatacopy1",
				input: []byte{0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0x0A, 0xBC, 0xDE, 0xF0},
				bytecode: MustSplice(PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x00, CALLDATACOPY, PUSH1, 0x00, MLOAD,
					PUSH1, 0x00, SSTORE, MSIZE, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x34, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60016001600037600051"
				name: "calldatacopy2",
				input: []byte{0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0x0A, 0xBC, 0xDE, 0xF0},
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x01, PUSH1, 0x00, CALLDATACOPY, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60006001600037600051"
				name: "calldatacopy3",
				input: []byte{0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0x0A, 0xBC, 0xDE, 0xF0},
				bytecode: MustSplice(PUSH1, 0x00, PUSH1, 0x01, PUSH1, 0x00, CALLDATACOPY, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6001600237"
				name: "calldatacopy4_DataStackUnderflow",
				input: []byte{0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0x0A, 0xBC, 0xDE, 0xF0},
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x02, CALLDATACOPY, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.DataStackUnderflow,
			},
			{
				// "code": "0x60ff7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa600037600051"
				name: "calldatacopy5_DataIndexTooHigh",
				input: []byte{0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
					0x01, 0x23, 0x45, 0x67, 0x89, 0x0A, 0xBC, 0xDE, 0xF0},
				bytecode: MustSplice(PUSH1, 0xFF, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFA, PUSH1, 0x00, CALLDATACOPY, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.IntegerOverflow,
			},
			/*
				{
					// TODO
					// "code": "0x6005565b005b6042601f536101036000601f3760005180606014600357640badc0ffee60ff55"
					name: "calldatacopy6",
					bytecode: MustSplice(PUSH1, 0x05, JUMP, JUMPDEST, 0x00, JUMPDEST, PUSH1, 0x42, PUSH1, 0x1F, MSTORE8,
						PUSH2, 0x01, 0x03, PUSH1, 0x00, PUSH1, 0x1F, CALLDATACOPY, PUSH1, 0x00, MLOAD, DUP1, PUSH1, 0x60, EQ,
						PUSH1, 0x03, JUMPI, PUSH5, 0x0B, 0xAD, 0xC0, 0xFF, 0xEE, PUSH1, 0xff, SSTORE, return1()),
					expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
					expected_err: errors.Codes.None,
				},
			*/
			{
				// "code": "0x600035"
				name:     "calldataload0",
				input:    []byte{0x25, 0x60},
				bytecode: MustSplice(PUSH1, 0x00, CALLDATALOAD, return1()),
				expected_out: []byte{0x25, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600135"
				name: "calldataload1",
				input: []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23},
				bytecode: MustSplice(PUSH1, 0x01, CALLDATALOAD, return1()),
				expected_out: []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600535"
				name: "calldataload2",
				input: []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24},
				bytecode: MustSplice(PUSH1, 0x05, CALLDATALOAD, return1()),
				expected_out: []byte{0xBC, 0xDE, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa35"
				name: "calldataload3_DataIndexTooHigh",
				input: []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24},
				bytecode: MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFA, CALLDATALOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.IntegerOverflow,
			},
			{
				// "code": "0x600a35"
				name: "calldataload4",
				input: []byte{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24},
				bytecode: MustSplice(PUSH1, 0x0A, CALLDATALOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x36"
				name:     "calldatasize0",
				input:    []byte{0x25, 0x60},
				bytecode: MustSplice(CALLDATASIZE, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x36"
				name: "calldatasize1",
				input: []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23},
				bytecode: MustSplice(CALLDATASIZE, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x36"
				name: "calldatasize2",
				input: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23},
				bytecode: MustSplice(CALLDATASIZE, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x33"
				name:     "caller",
				bytecode: MustSplice(CALLER, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x82, 0xDF, 0x09, 0x50,
					0xF5, 0xA9, 0x51, 0x63, 0x7E, 0x03, 0x07, 0xCD,
					0xCB, 0x4C, 0x67, 0x2F, 0x29, 0x8B, 0x8B, 0xC6},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x34"
				name:     "callvalue",
				value:    1000000000000000000,
				bytecode: MustSplice(CALLVALUE, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x0D, 0xE0, 0xB6, 0xB3, 0xA7, 0x64, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60056000600039600051"
				name:     "codecopy0",
				bytecode: MustSplice(PUSH1, 0x05, PUSH1, 0x00, PUSH1, 0x00, CODECOPY, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x60, 0x05, 0x60, 0x00, 0x60, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60006000600039600051"
				name:     "codecopy1",
				bytecode: MustSplice(PUSH1, 0x00, PUSH1, 0x00, PUSH1, 0x00, CODECOPY, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60087ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa600039600051"
				name: "codecopy2_DataIndexTooHigh",
				bytecode: MustSplice(PUSH1, 0x08, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFA, PUSH1, 0x00, CODECOPY, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.IntegerOverflow,
			},
			{
				// "code": "0x3860005260206000f3"
				name:     "codesize",
				bytecode: MustSplice(CODESIZE, PUSH1, 0x00, MSTORE, PUSH1, 0x20, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09},
				expected_err: errors.Codes.None,
			},
			{
				// TODO
				// "code": "0x3a"
				name:     "gasprice",
				bytecode: MustSplice(GASPRICE_DEPRECATED, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x32"
				name:     "origin",
				origin:   account1,
				bytecode: MustSplice(ORIGIN, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x82, 0xDF, 0x09, 0x50,
					0xF5, 0xA9, 0x51, 0x63, 0x7E, 0x03, 0x07, 0xCD,
					0xCB, 0x4C, 0x67, 0x2F, 0x29, 0x8B, 0x8B, 0xC6},
				expected_err: errors.Codes.None,
			},
		}
		for _, tt := range tests {
			value := big.NewInt(int64(tt.value))
			addToBalance(t, st, account1, tt.value)
			params := engine.CallParams{
				Origin: tt.origin,
				Caller: account1,
				Callee: account2,
				Input:  tt.input,
				Value:  *value,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_err, errors.GetCode(err))
			} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_out, output)
			}
		}
	})

	t.Run("IO and flow operations tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 110000

		tests := []struct {
			name         string
			blockHeight  uint64
			origin       crypto.Address
			input        []byte
			value        uint64
			pre          []byte
			bytecode     []byte
			expected_out []byte
			expected_err *errors.Code
		}{
			{
				// "code": "0x6023600b60085043015660015b"
				// "code": "0x6023600843015660015b"
				name:        "BlockNumberDynamicJump0_AfterJumpdest0",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x08, BLOCKHEIGHT, ADD, JUMP,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6023600b60085043015660015b"
				name:        "BlockNumberDynamicJump1_AfterJumpdest1",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x0B, PUSH1, 0x08, POP, BLOCKHEIGHT, ADD, JUMP,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6023600743015660015b"
				name:        "BlockNumberDynamicJump2_Jumpdest0",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x07, BLOCKHEIGHT, ADD, JUMP,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x602360074301566001"
				name:        "BlockNumberDynamicJump3_withoutJumpdest",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x07, BLOCKHEIGHT, ADD, JUMP,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x620fffff620fffff01430156"
				name:        "BlockNumberDynamicJump4",
				blockHeight: 2,
				bytecode:    MustSplice(PUSH3, 0x0F, 0xFF, 0xFF, PUSH3, 0x0F, 0xFF, 0xFF, ADD, BLOCKHEIGHT, JUMP, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6004430156655b6001600155"
				name:        "BlockNumberDynamicJump5_InsidePushWithJumpDest",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x04, BLOCKHEIGHT, ADD, JUMP,
					PUSH6, JUMPDEST, 0x60, 0x01, 0x60, 0x01, 0x55, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x600543015661eeff"
				name:        "BlockNumberDynamicJump6_InsidePushWithoutJumpDest",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x05, BLOCKHEIGHT, ADD, BLOCKHEIGHT, JUMP,
					PUSH2, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6023600160094301576001"
				name:        "BlockNumberDynamicJumpi0",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x01, PUSH1, 0x09, BLOCKHEIGHT, ADD, JUMPI,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6023600060094301576001"
				name:        "BlockNumberDynamicJumpi1",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x00, PUSH1, 0x09, BLOCKHEIGHT, ADD, JUMPI,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60236001600a43015760015b"
				name:        "BlockNumberDynamicJumpi2_Jumpdest",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x01, PUSH1, 0x0A, BLOCKHEIGHT, ADD, JUMPI,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x600160084301570060015b6002600355"
				name:        "BlockNumberDynamicJumpi3_AfterStop",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x08, BLOCKHEIGHT, ADD, JUMPI, 0x00, PUSH1, 0x01,
					JUMPDEST, PUSH1, 0x02, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60017ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04301576002"
				name:        "BlockNumberDynamicJumpi4_OutsideBoundary",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x01, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, BLOCKHEIGHT, ADD, JUMPI, PUSH1, 0x02, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.IntegerOverflow,
			},
			{
				// "code": "0x60016006430157655b6001600155"
				blockHeight: 2,
				name:        "BlockNumberDynamicJumpi5_InsidePushWithJumpDest",
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x06, BLOCKHEIGHT, ADD, JUMPI,
					PUSH6, JUMPDEST, 0x60, 0x01, 0x60, 0x01, 0x55, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6001600743015761eeff"
				name:        "BlockNumberDynamicJumpi6_InsidePushWithoutJumpDest",
				blockHeight: 2,
				bytecode:    MustSplice(PUSH1, 0x01, PUSH1, 0x07, BLOCKHEIGHT, ADD, JUMPI, PUSH2, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6023600760005401566001"
				name:     "DyanmicJump0_OutOfBoundary",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x07, PUSH1, 0x00, SLOAD, ADD, JUMP, PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x602360086003015660015b"
				name:     "DynamicJump1_AfterJumpdest0",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x08, PUSH1, 0x03, ADD, JUMP, PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6023600b6008506003015660015b600255"
				name: "DynamicJump2_AfterJumpdest1",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x0B, PUSH1, 0x08, POP, PUSH1, 0x03, ADD,
					JUMP, PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x602360076003015660015b600255"
				name:     "DynamicJump3_Jumpdest0",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x07, PUSH1, 0x03, ADD, JUMP, PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6023600a6008506003015660015b"
				name: "DynamicJump4_Jumpdest1",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x0A, PUSH1, 0x08, POP, PUSH1, 0x03, ADD,
					JUMP, PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60236007600301566001"
				name:     "DynamicJump5_WithoutJumpdest",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x07, PUSH1, 0x03, ADD, JUMP, PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x620fffff620fffff0160030156"
				name: "DynamicJump6",
				bytecode: MustSplice(PUSH3, 0x0F, 0xFF, 0xFF, PUSH3, 0x0F, 0xFF, 0xFF, ADD,
					PUSH1, 0x03, ADD, JUMP, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6008600101560060015b6002600355"
				name: "DynamicJump7_AfterStop",
				bytecode: MustSplice(PUSH1, 0x08, PUSH1, 0x01, ADD, JUMP, 0x00, PUSH1, 0x01,
					JUMPDEST, PUSH1, 0x02, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600460030156655b6001600155"
				name: "DynamicJump8_InsidePushWithJumpDest",
				bytecode: MustSplice(PUSH1, 0x04, PUSH1, 0x03, ADD, JUMP, PUSH6, JUMPDEST,
					0x60, 0x01, 0x60, 0x01, 0x55, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60056003015661eeff"
				name:     "DynamicJump9_InsidePushWithoutJumpDest",
				bytecode: MustSplice(PUSH1, 0x05, PUSH1, 0x03, ADD, JUMP, PUSH2, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x435660615b4343025660615b60615b5b5b6001"
				name:        "DynamicJump10_PathologicalTest0",
				blockHeight: 4,
				bytecode: MustSplice(BLOCKHEIGHT, JUMP, PUSH1, 0x61, JUMPDEST, BLOCKHEIGHT, BLOCKHEIGHT, MUL,
					JUMP, PUSH1, 0x61, JUMPDEST, PUSH1, 0x61, JUMPDEST, JUMPDEST, JUMPDEST, PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x435660615b4343025660615b60615b605b6001"
				name:        "DynamicJump11_PathologicalTest1",
				blockHeight: 4,
				bytecode: MustSplice(BLOCKHEIGHT, JUMP, PUSH1, 0x61, JUMPDEST, BLOCKHEIGHT, BLOCKHEIGHT, MUL,
					JUMP, PUSH1, 0x61, JUMPDEST, PUSH1, 0x61, JUMPDEST, PUSH1, JUMPDEST, PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x435631615b60615b60615b606001"
				name:        "DynamicJump12_PathologicalTest2",
				blockHeight: 4,
				bytecode: MustSplice(BLOCKHEIGHT, JUMP, 0x31, PUSH2, JUMPDEST, 0x60, PUSH2, JUMPDEST, 0x60, PUSH2, JUMPDEST, 0x60,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x435631615b60615b60615b606001"
				name:        "DynamicJump13_PathologicalTest3",
				blockHeight: 7,
				bytecode: MustSplice(BLOCKHEIGHT, JUMP, 0x31, PUSH2, JUMPDEST, 0x60, PUSH2, JUMPDEST, 0x60, PUSH2, JUMPDEST, 0x60,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6009436006575b566001"
				name:        "DynamicJump14_JDDependsOnJumps0",
				blockHeight: 2,
				bytecode:    MustSplice(PUSH1, 0x09, BLOCKHEIGHT, PUSH1, 0x06, JUMPI, JUMPDEST, JUMP, PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x600a436006575b5660015b6001"
				name:        "DynamicJump15_JDDependsOnJumps1",
				blockHeight: 2,
				bytecode: MustSplice(PUSH1, 0x0A, BLOCKHEIGHT, PUSH1, 0x06, JUMPI, JUMPDEST, JUMP,
					PUSH1, 0x01, JUMPDEST, PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x5b586000555960115758600052596000575b58"
				name: "DynamicJump16_StartWithJumpDest",
				bytecode: MustSplice(JUMPDEST, PC, PUSH1, 0x00, SSTORE, MSIZE, PUSH1, 0x11, JUMPI, PC, PUSH1, 0x00, 0x52, MSIZE,
					PUSH1, 0x00, JUMPI, JUMPDEST, PC, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x12},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60016002600334565b5050600052596000f35b50600052596000f35b600052596000f3"
				name:  "DynamicJump17_Value0",
				value: 0x08,
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x02, PUSH1, 0x03, CALLVALUE, JUMP, JUMPDEST, POP, POP,
					PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN, JUMPDEST, POP, PUSH1, 0x00, MSTORE, MSIZE,
					PUSH1, 0x00, RETURN, JUMPDEST, PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60016002600334565b5050600052596000f35b50600052596000f35b600052596000f3"
				name:  "DynamicJump18_Value1",
				value: 0x12,
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x02, PUSH1, 0x03, CALLVALUE, JUMP, JUMPDEST, POP, POP,
					PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN, JUMPDEST, POP, PUSH1, 0x00, MSTORE, MSIZE,
					PUSH1, 0x00, RETURN, JUMPDEST, PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60016002600334565b5050600052596000f35b50600052596000f35b600052596000f3"
				name:  "DynamicJump19_Value2",
				value: 0x1B,
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x02, PUSH1, 0x03, CALLVALUE, JUMP, JUMPDEST, POP, POP,
					PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN, JUMPDEST, POP, PUSH1, 0x00, MSTORE, MSIZE,
					PUSH1, 0x00, RETURN, JUMPDEST, PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60016002600334565b5050600052596000f35b50600052596000f35b505050600052596000f3"
				name:  "DynamicJump20_ValueUnderflow",
				value: 0x1B,
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x02, PUSH1, 0x03, CALLVALUE, JUMP, JUMPDEST, POP, POP,
					PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN, JUMPDEST, POP, PUSH1, 0x00, MSTORE, MSIZE,
					PUSH1, 0x00, RETURN, JUMPDEST, POP, POP, POP, PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.DataStackUnderflow,
			},
			{
				// "code": "0x602360016009600301576001"
				name: "DynamicJumpi0",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x01, PUSH1, 0x09, PUSH1, 0x03, ADD, JUMPI,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x602360006009600301576001"
				name: "DynamicJumpi1",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x00, PUSH1, 0x09, PUSH1, 0x03, ADD, JUMPI,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60236001600a6003015760015b"
				name: "DynamicJumpi2_Jumpdest",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x01, PUSH1, 0x0A, PUSH1, 0x03, ADD, JUMPI,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60016008600301570060015b6002"
				name: "DynamicJumpi3_AfterStop",
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x08, PUSH1, 0x03, ADD, JUMPI, 0x00,
					PUSH1, 0x01, JUMPDEST, PUSH1, 0x02, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60017ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0600301576002"
				name: "DynamicJumpi4_OutsideBoundary",
				bytecode: MustSplice(PUSH1, 0x01, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, PUSH1, 0x03, ADD, JUMPI, PUSH1, 0x02, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.IntegerOverflow,
			},
			{
				// "code": "0x6001600660030157655b6001600155"
				name: "DynamicJumpi5_InsidePushWithJumpDest",
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x06, PUSH1, 0x03, ADD, JUMPI,
					PUSH6, JUMPDEST, 0x60, 0x01, 0x60, 0x01, 0x55, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6001600660030157655b6001600155"
				name: "DynamicJumpi6_InsidePushWithJumpDest",
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x07, PUSH1, 0x03, ADD, JUMPI,
					PUSH2, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60236008600054015660015b"
				name: "JDfromStorageDynamicJump0_AfterJumpdest0",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x08, PUSH1, 0x00, SLOAD, ADD, JUMP,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6023600b600850600054015660015b"
				name: "JDfromStorageDynamicJump1_AfterJumpdest1",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x0B, PUSH1, 0x08, POP, PUSH1, 0x00, SLOAD, ADD, JUMP,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60236007600054015660015b"
				name: "JDfromStorageDynamicJump2_Jumpdest0",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x07, PUSH1, 0x00, SLOAD, ADD, JUMP,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6023600a600850600054015660015b"
				name: "JDfromStorageDynamicJump3_Jumpdest1",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x0A, PUSH1, 0x08, POP, PUSH1, 0x00, SLOAD, ADD, JUMP,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6023600760005401566001"
				name: "JDfromStorageDynamicJump4__WithoutJumpdest",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x07, PUSH1, 0x00, SLOAD, ADD, JUMP,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x620fffff620fffff016000540156"
				name: "JDfromStorageDynamicJump5",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH3, 0x0F, 0xFF, 0xFF, PUSH3, 0x0F, 0xFF, 0xFF, ADD,
					PUSH1, 0x00, SLOAD, ADD, JUMP, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60046000540156655b6001600155"
				name: "JDfromStorageDynamicJump6_JumpInsidePushWithJumpDest",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x04, PUSH1, 0x00, SLOAD, ADD, JUMP,
					PUSH6, JUMPDEST, 0x60, 0x01, 0x60, 0x01, 0x55, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6005600054015661eeff"
				name:     "JDfromStorageDynamicJump7_JumpInsidePushWithoutJumpDest",
				pre:      MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x05, PUSH1, 0x00, SLOAD, ADD, JUMP, PUSH2, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60236001600960005401576001"
				name: "JDfromStorageDynamicJumpi0",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x01, PUSH1, 0x09, PUSH1, 0x00, SLOAD, ADD, JUMPI,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60236000600960005401576001"
				name: "JDfromStorageDynamicJumpi1",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x00, PUSH1, 0x09, PUSH1, 0x00, SLOAD, ADD, JUMPI,
					PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60236001600a600054015760015b"
				name: "JDfromStorageDynamicJumpi2_Jumpdest",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x01, PUSH1, 0x0A, PUSH1, 0x00, SLOAD, ADD, JUMPI,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6001600860005401570060015b6002"
				name: "JDfromStorageDynamicJumpi3_AfterStop",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x08, PUSH1, 0x00, SLOAD, ADD, JUMPI, 0x00,
					PUSH1, 0x01, JUMPDEST, PUSH1, 0x02, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60017ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff060005401576002"
				name: "JDfromStorageDynamicJumpi4_OutsideBoundary",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x01, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, PUSH1, 0x00, SLOAD, ADD, JUMPI, PUSH1, 0x02, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.IntegerOverflow,
			},
			{
				// "code": "0x600160066000540157655b6001600155"
				name: "JDfromStorageDynamicJumpi5_JumpInsidePushWithJumpDest",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x06, PUSH1, 0x00, SLOAD, ADD, JUMPI,
					PUSH6, JUMPDEST, 0x60, 0x01, 0x60, 0x01, 0x55, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60016007600054015761eeff"
				name: "JDfromStorageDynamicJumpi5_JumpInsidePushWithoutJumpDest",
				pre:  MustSplice(PUSH1, 0x04, PUSH1, 0x00, SSTORE),
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x07, PUSH1, 0x00, SLOAD, ADD, JUMPI,
					PUSH2, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x601b602502565b"
				name:     "BadIndirectJump0",
				bytecode: MustSplice(PUSH1, 0x1B, PUSH1, 0x25, MUL, JUMP, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60016003600302576000600056"
				name: "BadIndirectJump1",
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x03, PUSH1, 0x03, MUL, JUMPI,
					PUSH1, 0x00, PUSH1, 0x00, JUMP, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x600460030156005b6001600052596000f3"
				name: "IndirectJump0",
				bytecode: MustSplice(PUSH1, 0x04, PUSH1, 0x03, ADD, JUMP, 0x00, JUMPDEST,
					PUSH1, 0x01, PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600860060156005b6001600052005b6002600052596000f3"
				name: "IndirectJump1",
				bytecode: MustSplice(PUSH1, 0x08, PUSH1, 0x06, ADD, JUMP, 0x00, JUMPDEST,
					PUSH1, 0x01, PUSH1, 0x00, MSTORE, 0x00, JUMPDEST,
					PUSH1, 0x02, PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6001600460050157005b6001600052596000f3"
				name: "IndirectJump2",
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x04, PUSH1, 0x05, ADD, JUMPI, 0x00, JUMPDEST,
					PUSH1, 0x01, PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60006007600501576001600052005b"
				name: "IndirectJump3",
				bytecode: MustSplice(PUSH1, 0x00, PUSH1, 0x07, PUSH1, 0x05, ADD, JUMPI,
					PUSH1, 0x01, PUSH1, 0x00, MSTORE, 0x00, JUMPDEST, return1()),
				expected_out: nil,
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x602360085660015b"
				name:         "jump0_AfterJumpdest0",
				bytecode:     MustSplice(PUSH1, 0x23, PUSH1, 0x08, JUMP, PUSH1, 0x01, JUMPDEST, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6023600b6008505660015b"
				name: "jump1_AfterJumpdest1",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x0B, PUSH1, 0x08, POP, JUMP,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x602360075660015b"
				name:     "jump2_Jumpdest0",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x07, JUMP, PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6023600a6008505660015b"
				name: "jump3_Jumpdest1",
				bytecode: MustSplice(PUSH1, 0x23, PUSH1, 0x0A, PUSH1, 0x08, POP, JUMP,
					PUSH1, 0x01, JUMPDEST, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x23},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60236007566001"
				name:         "jump4_OutOfBoundary",
				bytecode:     MustSplice(PUSH1, 0x23, PUSH1, 0x07, JUMP, PUSH1, 0x01, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x620fffff620fffff0156"
				name:         "jump5",
				bytecode:     MustSplice(PUSH3, 0x0F, 0xFF, 0xFF, PUSH3, 0x0F, 0xFF, 0xFF, ADD, JUMP, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6006560060015b6002"
				name:     "jump6_AfterStop",
				bytecode: MustSplice(PUSH1, 0x06, JUMP, 0x00, PUSH1, 0x01, JUMPDEST, PUSH1, 0x02, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6002600401565b600360005260206000f3600656"
				name: "jump7_DynamicJumpSameDest",
				bytecode: MustSplice(PUSH1, 0x02, PUSH1, 0x04, ADD, JUMP, JUMPDEST, PUSH1, 0x03, PUSH1, 0x00, MSTORE,
					PUSH1, 0x20, PUSH1, 0x00, RETURN, PUSH1, 0x06, JUMP, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600456655b6001600155"
				name:         "jump8_High",
				bytecode:     MustSplice(PUSH4, 0x0F, 0xFF, 0xFF, 0xFF, JUMP, JUMPDEST, JUMPDEST, PUSH1, 0x01, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x630fffffff565b5b6001"
				name:         "jump9_InsidePushWithJumpDest",
				bytecode:     MustSplice(PUSH1, 0x04, JUMP, PUSH6, JUMPDEST, 0x60, 0x01, 0x60, 0x01, 0x55, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60055661eeff"
				name:         "jump10_InsidePushWithoutJumpDest",
				bytecode:     MustSplice(PUSH1, 0x05, JUMP, PUSH2, 0xEE, 0xFF, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "60035656"
				name:         "jump11_OntoJump",
				bytecode:     MustSplice(PUSH1, 0x03, JUMP, JUMP, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6003565b6001"
				name:     "jump12_To1InstructionafterJump",
				bytecode: MustSplice(PUSH1, 0x03, JUMP, JUMPDEST, PUSH1, 0x01, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x5b6003565b6001"
				name:         "jump13_To1InstructionafterJump_JumpdestFirstInstruction",
				bytecode:     MustSplice(JUMPDEST, PUSH1, 0x03, JUMP, JUMPDEST, PUSH1, 0x01, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6003566001"
				name:         "jump14_To1InstructionafterJump_NoJumpdest",
				bytecode:     MustSplice(PUSH1, 0x03, JUMP, PUSH1, 0x01, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6801000000000000000b565b5b6001"
				name: "jump15_ToUint64maxPlus1",
				bytecode: MustSplice(PUSH9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, JUMP,
					JUMPDEST, JUMPDEST, PUSH1, 0x01, return1()),
				expected_err: errors.Codes.IntegerOverflow,
			},
			{
				// "code": "0x640100000007565b5b6001"
				name: "jump15_ToUintmaxPlus1",
				bytecode: MustSplice(PUSH5, 0x01, 0x00, 0x00, 0x00, 0x07, JUMP, JUMPDEST, JUMPDEST,
					PUSH1, 0x01, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6009565b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b5b"
				name: "jumpdest_BigList",
				bytecode: MustSplice(PUSH1, 0x09, JUMP, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST,
					JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, JUMPDEST, return1()),
				expected_err: errors.Codes.DataStackUnderflow,
			},
			{
				// "code": "0x602360016009576001"
				name:         "jumpi0",
				bytecode:     MustSplice(PUSH1, 0x23, PUSH1, 0x01, PUSH1, 0x09, JUMPI, PUSH1, 0x01, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60236001600a5760015b"
				name:         "jumpi1_Jumpdest",
				bytecode:     MustSplice(PUSH1, 0x23, PUSH1, 0x01, PUSH1, 0x0A, JUMPI, PUSH1, 0x01, JUMPDEST, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60016008570060015b6002"
				name: "jumpi2_AfterStop",
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x08, JUMPI, 0x00, PUSH1, 0x01,
					JUMPDEST, PUSH1, 0x02, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff576002"
				name: "jumpi3_OutsideBoundary",
				bytecode: MustSplice(PUSH1, 0x01, PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, JUMPI, PUSH1, 0x02, return1()),
				expected_err: errors.Codes.IntegerOverflow,
			},
			{
				// "code": "0x60016801000000000000000d575b5b6001"
				name: "jumpi4_ToUint64maxPlus1",
				bytecode: MustSplice(PUSH1, 0x01, PUSH9, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, JUMPI,
					JUMPDEST, JUMPDEST, PUSH1, 0x01, return1()),
				expected_err: errors.Codes.IntegerOverflow,
			},
			{
				// "code": "0x6001640100000009575b5b6001"
				name: "jumpi5_ToUintmaxPlus1",
				bytecode: MustSplice(PUSH1, 0x01, PUSH5, 0x01, 0x00, 0x00, 0x00, 0x09, JUMPI, JUMPDEST, JUMPDEST,
					PUSH1, 0x01, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x6001640100000009575b5b6001"
				name:         "jumpi6_InsidePushWithJumpDest",
				bytecode:     MustSplice(PUSH1, 0x01, PUSH1, 0x06, JUMPI, PUSH6, JUMPDEST, 0x60, 0x01, 0x60, 0x01, 0x55, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x600160075761eeff"
				name:         "jumpi7_InsidePushWithoutJumpDest",
				bytecode:     MustSplice(PUSH1, 0x01, PUSH1, 0x07, JUMPI, PUSH2, 0xEE, 0xFF, return1()),
				expected_err: errors.Codes.InvalidJumpDest,
			},
			{
				// "code": "0x60005A13"
				name:     "gas0",
				bytecode: MustSplice(PUSH1, 0x00, GASLIMIT, SGT, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x620186A05A12"
				name:     "gas2",
				bytecode: MustSplice(PUSH3, 0x01, 0x86, 0xA0, GASLIMIT, SLT, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x33604555602d80600f6000396000f3604554331415602c575b366080511015602b576020608051013560805135556040608051016080526009565b5b"
				name: "kv1",
				bytecode: MustSplice(CALLER, PUSH1, 0x45, SSTORE, PUSH1, 0x2D, 0x80, PUSH1, 0x0F,
					PUSH1, 0x00, CODECOPY, PUSH1, 0x00, RETURN, PUSH1, 0x45, SLOAD, CALLER, EQ, ISZERO,
					PUSH1, 0x2C, JUMPI, JUMPDEST, 0x36, PUSH1, 0x80, MLOAD, LT, ISZERO, PUSH1, 0x2B, JUMPI,
					PUSH1, 0x20, PUSH1, 0x80, MLOAD, ADD, CALLDATALOAD, PUSH1, 0x80, MLOAD, CALLDATALOAD, SSTORE,
					PUSH1, 0x40, PUSH1, 0x80, MLOAD, ADD, PUSH1, 0x80, MSTORE, PUSH1, 0x09, JUMP, JUMPDEST, JUMPDEST, return1()),
				expected_out: []byte{0x60, 0x45, 0x54, 0x33, 0x14, 0x15, 0x60, 0x2C, 0x57,
					0x5B, 0x36, 0x60, 0x80, 0x51, 0x10, 0x15, 0x60,
					0x2B, 0x57, 0x60, 0x20, 0x60, 0x80, 0x51, 0x01,
					0x35, 0x60, 0x80, 0x51, 0x35, 0x55, 0x60, 0x40,
					0x60, 0x80, 0x51, 0x01, 0x60, 0x80, 0x52, 0x60,
					0x09, 0x56, 0x5B, 0x5B},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600260005360036001536000516001510160025260406000f3"
				name: "memory0",
				bytecode: MustSplice(PUSH1, 0x02, PUSH1, 0x00, MSTORE8, PUSH1, 0x03, PUSH1, 0x01, MSTORE8,
					PUSH1, 0x00, MLOAD, PUSH1, 0x01, MLOAD, ADD, PUSH1, 0x02, MSTORE, PUSH1, 0x40, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x02, 0x03, 0x05, 0x03, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// TODO
				// should return error?
				// "code": "0x600051"
				name:     "mload0_Error0",
				bytecode: MustSplice(PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// TODO
				// should return error?
				// "code": "0x6017600152600051"
				name:     "mload1_Error1",
				bytecode: MustSplice(PUSH1, 0x17, PUSH1, 0x01, MSTORE, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x630fffffff51"
				name:         "mload2_MemExp",
				bytecode:     MustSplice(PUSH4, 0x0F, 0xFF, 0xFF, 0xFF, MLOAD, return1()),
				expected_err: errors.Codes.Generic,
			},
			{
				// "code": "0x6272482551"
				name:         "mload3_OutOfGasError",
				bytecode:     MustSplice(PUSH3, 0x72, 0x48, 0x25, MLOAD, return1()),
				expected_err: errors.Codes.InsufficientGas,
			},
			{
				// "code": "0x60ff60005259"
				name:     "msize0",
				bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x00, MSTORE, MSIZE, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x64ffffffffff60005259"
				name:     "msize1",
				bytecode: MustSplice(PUSH5, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, MSTORE, MSIZE, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x64ffffffffff60005261eeee60205259"
				name: "msize2",
				bytecode: MustSplice(PUSH5, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, MSTORE,
					PUSH2, 0xEE, 0xEE, PUSH1, 0x20, MSTORE, MSIZE, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x64ffffffffff60005261eeee605a5259"
				name: "msize3",
				bytecode: MustSplice(PUSH5, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, PUSH1, 0x00, MSTORE,
					PUSH2, 0xEE, 0xEE, PUSH1, 0x5A, MSTORE, MSIZE, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600152600151"
				name: "mstore0",
				bytecode: MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH1, 0x01, MSTORE, PUSH1, 0x01, MLOAD, return1()),
				expected_out: []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600201600152600151"
				name: "mstore1",
				bytecode: MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH1, 0x02, ADD, PUSH1, 0x01, MSTORE, PUSH1, 0x01, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60f1630fffffff52"
				name:     "mstore2_MemExp",
				bytecode: MustSplice(PUSH1, 0xF1, PUSH4, 0x0F, 0xFF, 0xFF, 0xFF, MSTORE, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.Generic,
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600152600151"
				name: "mstore3_WordToBigError",
				bytecode: MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH1, 0x01, MSTORE, PUSH1, 0x01, MLOAD, return1()),
				expected_out: []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6017600052600051"
				name:     "mstore4_mload",
				bytecode: MustSplice(PUSH1, 0x17, PUSH1, 0x00, MSTORE, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60f1630fffffff53"
				name:         "mstore8_0_MemExp",
				bytecode:     MustSplice(PUSH1, 0xF1, PUSH4, 0x0F, 0xFF, 0xFF, 0xFF, MSTORE8, return1()),
				expected_err: errors.Codes.Generic,
			},
			{
				// "code": "0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600153600151"
				name: "mstore8_1_WordToBigError",
				bytecode: MustSplice(PUSH32, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					PUSH1, 0x01, MSTORE8, PUSH1, 0x01, MLOAD, return1()),
				expected_out: []byte{0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60ff60015360ee600253600051"
				name: "mstore8_2",
				bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x01, MSTORE8,
					PUSH1, 0xEE, PUSH1, 0x02, MSTORE8, PUSH1, 0x00, MLOAD, return1()),
				expected_out: []byte{0x00, 0xFF, 0xEE, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x58"
				name:     "pc0",
				bytecode: MustSplice(PC, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60ff60005558"
				name:     "pc1",
				bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x00, SSTORE, PC, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6002600360045055600354"
				name: "pop0",
				bytecode: MustSplice(PUSH1, 0x02, PUSH1, 0x03, PUSH1, 0x04, POP, SSTORE,
					PUSH1, 0x03, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x5060026003600455"
				name:         "pop1",
				bytecode:     MustSplice(POP, PUSH1, 0x02, PUSH1, 0x03, PUSH1, 0x04, SSTORE),
				expected_err: errors.Codes.DataStackUnderflow,
			},
			{
				// "code": "0x6001620f4240f3"
				name:         "return0",
				bytecode:     MustSplice(PUSH1, 0x01, PUSH3, 0x0F, 0x42, 0x40, RETURN),
				expected_err: errors.Codes.InsufficientGas,
			},
			{
				// "code": "0x6001608052600060805111601b57600160005260206000f3602b565b602760005260206000f360026080525b"
				name: "return1",
				bytecode: MustSplice(PUSH1, 0x01, PUSH1, 0x80, MSTORE, PUSH1, 0x00, PUSH1, 0x80, MLOAD, GT,
					PUSH1, 0x1B, JUMPI, PUSH1, 0x01, PUSH1, 0x00, MSTORE, PUSH1, 0x20, PUSH1, 0x00, RETURN,
					PUSH1, 0x2B, JUMP, JUMPDEST, PUSH1, 0x27, PUSH1, 0x00, MSTORE, PUSH1, 0x20, PUSH1, 0x00, RETURN,
					PUSH1, 0x02, PUSH1, 0x80, MSTORE, JUMPDEST),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x27},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60ff630fffffff20"
				name:         "sha3_MemExp",
				bytecode:     MustSplice(PUSH1, 0xFF, PUSH4, 0x0F, 0xFF, 0xFF, 0xFF, SHA3),
				expected_err: errors.Codes.Generic,
			},
			{
				// "code": "0x60ff60005560ee600a55600054601455601454"
				name: "sstore_load_0",
				bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x00, SSTORE, PUSH1, 0xEE, PUSH1, 0x0A, SSTORE,
					PUSH1, 0x00, SLOAD, PUSH1, 0x14, SSTORE, PUSH1, 0x14, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60ff60005560ee600a55600054601455600a54"
				name: "sstore_load_1",
				bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x00, SSTORE, PUSH1, 0xEE, PUSH1, 0x0A, SSTORE,
					PUSH1, 0x00, SLOAD, PUSH1, 0x14, SSTORE, PUSH1, 0x0A, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60ff60005560ee600a55600054601455600054"
				name: "sstore_load_2",
				bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x00, SSTORE, PUSH1, 0xEE, PUSH1, 0x0A, SSTORE,
					PUSH1, 0x00, SLOAD, PUSH1, 0x14, SSTORE, PUSH1, 0x00, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60ff60005560ee600a55606454601455600a54"
				name: "sstore_load_3",
				bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x00, SSTORE, PUSH1, 0xEE, PUSH1, 0x0A, SSTORE,
					PUSH1, 0x64, SLOAD, PUSH1, 0x14, SSTORE, PUSH1, 0x0A, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60ff60005560ee600a55606454601455600054"
				name: "sstore_load_4",
				bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x00, SSTORE, PUSH1, 0xEE, PUSH1, 0x0A, SSTORE,
					PUSH1, 0x64, SLOAD, PUSH1, 0x14, SSTORE, PUSH1, 0x00, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60ff60005560ee60015560dd600255600154600a55600254601455"
				name: "sstore_load_5",
				bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x00, SSTORE, PUSH1, 0xEE, PUSH1, 0x01, SSTORE,
					PUSH1, 0xDD, PUSH1, 0x02, SSTORE, PUSH1, 0x01, SLOAD, PUSH1, 0x0A, SSTORE,
					PUSH1, 0x02, SLOAD, PUSH1, 0x14, SSTORE),
				expected_out: nil,
				expected_err: errors.Codes.None,
			},
			/*
				{
					// TODO
					// should be underflow rather than insufficient gas?
					// "code": "0x600155"
					name: "sstore_Underflow",
					bytecode: MustSplice(PUSH1, 0x01, SSTORE),
					expected_err: errors.Codes.InsufficientGas,
				},
			*/
			{
				// "code": "0x60015b6001810380600257600053600153600253600353600453600553600653600753600853600953596000f3"
				name: "Stack_Loop",
				bytecode: MustSplice(PUSH1, 0x01, JUMPDEST, PUSH1, 0x01, DUP2, SUB, DUP1, PUSH1, 0x02, JUMPI,
					PUSH1, 0x00, MSTORE8, PUSH1, 0x01, MSTORE8, PUSH1, 0x02, MSTORE8, PUSH1, 0x03, MSTORE8,
					PUSH1, 0x04, MSTORE8, PUSH1, 0x05, MSTORE8, PUSH1, 0x06, MSTORE8, PUSH1, 0x07, MSTORE8,
					PUSH1, 0x08, MSTORE8, PUSH1, 0x09, MSTORE8, MSIZE, PUSH1, 0x00, RETURN),
				expected_err: errors.Codes.DataStackUnderflow,
			},
			{
				// "code": "0x6004600660096014565b600a03600052596000f35b60005201600956"
				name: "StackJump",
				bytecode: MustSplice(PUSH1, 0x04, PUSH1, 0x06, PUSH1, 0x09, PUSH1, 0x14, JUMP, JUMPDEST,
					PUSH1, 0x0A, SUB, PUSH1, 0x00, MSTORE, MSIZE, PUSH1, 0x00, RETURN,
					JUMPDEST, PUSH1, 0x00, MSTORE, ADD, PUSH1, 0x09, JUMP),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600060011115600e57600d6080525b608051"
				name: "when",
				bytecode: MustSplice(PUSH1, 0x00, PUSH1, 0x01, GT, ISZERO, PUSH1, 0x0E, JUMPI,
					PUSH1, 0x0D, PUSH1, 0x80, MSTORE, JUMPDEST, PUSH1, 0x80, MLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D},
				expected_err: errors.Codes.None,
			},
		}
		for _, tt := range tests {
			blockchain.blockHeight = tt.blockHeight
			addToBalance(t, st, account1, tt.value)
			params := engine.CallParams{
				Caller: account1,
				Callee: account2,
				Gas:    big.NewInt(int64(gas)),
			}
			if _, err := vm.Execute(st, blockchain, eventSink, params, tt.pre); err != nil {
				t.Errorf("FAIL: pre-%v.", tt.name)
				assert.NoError(t, err)
			}
			value := big.NewInt(int64(tt.value))
			params = engine.CallParams{
				Origin: tt.origin,
				Caller: account1,
				Callee: account2,
				Input:  tt.input,
				Value:  *value,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_err, errors.GetCode(err))
			} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_out, output)
			}
		}
	})

	t.Run("Infinite loop tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		blockchain.blockHeight = 2

		tests := []struct {
			name         string
			gas          uint64
			bytecode     []byte
			expected_out []byte
			expected_err *errors.Code
		}{
			{
				// "code": "0x5b600060000156"
				name:     "DynamicJump_ForeverOutOfGas",
				gas:      100000,
				bytecode: MustSplice(JUMPDEST, PUSH1, 0x00, PUSH1, 0x00, ADD, JUMP, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.InsufficientGas,
			},
		}
		for _, tt := range tests {
			params := engine.CallParams{
				Caller: account1,
				Callee: account2,
				Gas:    big.NewInt(int64(tt.gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_err, errors.GetCode(err))
			} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_out, output)
			}
		}
	})

	/*
		t.Run("Log tests", func(t *testing.T) {
			st := acmstate.NewMemoryState()
			blockchain := new(blockchain)
			eventSink := exec.NewNoopEventSink()
			// eventSink := exec.NewLogFreeEventSink(nil)

			account1 := newAccount(t, st, "1")
			account2 := newAccount(t, st, "101")
			var gas uint64 = 100000

			tests := []struct {
				name			string
				origin			crypto.Address
				input			[]byte
				value			uint64
				bytecode		[]byte
				expected_out	[]byte
				expected_err	*errors.Code
			} {
				{
					// "code": "0x60ff6000533360206000a1"
					name: "log1_Caller",
					bytecode: MustSplice(PUSH1, 0xFF, PUSH1, 0x00, MSTORE8, CALLER, PUSH1, 0x20, PUSH1, 0x00, LOG1),
					expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
						0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
					expected_err: errors.Codes.None,
				},
			}
			for _, tt := range tests {
				params := engine.CallParams{
					Origin: tt.origin,
					Caller: account1,
					Callee: account2,
					Input:	tt.input,
					Value:	tt.value,
					Gas:    big.NewInt(int64(gas)),
				}
				if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
					t.Errorf("FAIL: %v.", tt.name)
					assert.Equal(t, tt.expected_err, errors.GetCode(err))
				} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
					t.Errorf("FAIL: %v.", tt.name)
					assert.Equal(t, tt.expected_out, output)
				}
			}
		})
	*/

	/*
		t.Run("Performance tests", func(t *testing.T) {
			st := acmstate.NewMemoryState()
			blockchain := new(blockchain)
			eventSink := exec.NewNoopEventSink()

			account1 := newAccount(t, st, "1")
			account2 := newAccount(t, st, "101")
			var gas uint64 = 100000

			tests := []struct {
				name			string
				origin			crypto.Address
				input			[]byte
				value			uint64
				bytecode		[]byte
				expected_out	[]byte
				expected_err	*errors.Code
			} {
				{},
			}
			for _, tt := range tests {
				params := engine.CallParams{
					Origin: tt.origin,
					Caller: account1,
					Callee: account2,
					Input:	tt.input,
					Value:	tt.value,
					Gas:    big.NewInt(int64(gas)),
				}
				if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
					t.Errorf("FAIL: %v.", tt.name)
					assert.Equal(t, tt.expected_err, errors.GetCode(err))
				} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
					t.Errorf("FAIL: %v.", tt.name)
					assert.Equal(t, tt.expected_out, output)
				}
			}
		})
	*/

	t.Run("Push and dup tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 100000

		tests := []struct {
			name         string
			bytecode     []byte
			expected_out []byte
			expected_err *errors.Code
		}{
			{
				// "code": "0x60ff"
				name:     "push1",
				bytecode: MustSplice(PUSH1, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
				expected_err: errors.Codes.None,
			},
			/*
				{
					// TODO
					// should it return StackUnderflow error?
					// "code": "0x60"
					name: "push1_MissingStack",
					bytecode: MustSplice(PUSH1, return1()),
					expected_err: errors.Codes.None,
				},
			*/
			{
				// "code": "0x61eeff"
				name:     "push2",
				bytecode: MustSplice(PUSH2, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x62ddeeff"
				name:     "push3",
				bytecode: MustSplice(PUSH3, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x63ccddeeff"
				name:     "push4",
				bytecode: MustSplice(PUSH4, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x64bbccddeeff"
				name:     "push5",
				bytecode: MustSplice(PUSH5, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x65aabbccddeeff"
				name:     "push6",
				bytecode: MustSplice(PUSH6, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6699aabbccddeeff"
				name:     "push7",
				bytecode: MustSplice(PUSH7, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x678899AABBCCDDEEFF"
				name:     "push8",
				bytecode: MustSplice(PUSH8, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x68778899AABBCCDDEEFF"
				name: "push9",
				bytecode: MustSplice(PUSH9, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE,
					0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6966778899AABBCCDDEEFF"
				name: "push10",
				bytecode: MustSplice(PUSH10, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD,
					0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6a5566778899AABBCCDDEEFF"
				name: "push11",
				bytecode: MustSplice(PUSH11, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC,
					0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6b445566778899AABBCCDDEEFF"
				name: "push12",
				bytecode: MustSplice(PUSH12, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB,
					0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6c33445566778899AABBCCDDEEFF"
				name: "push13",
				bytecode: MustSplice(PUSH13, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA,
					0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6d2233445566778899AABBCCDDEEFF"
				name: "push14",
				bytecode: MustSplice(PUSH14, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
					0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6e112233445566778899AABBCCDDEEFF"
				name: "push15",
				bytecode: MustSplice(PUSH15, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
					0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6f10112233445566778899AABBCCDDEEFF"
				name: "push16",
				bytecode: MustSplice(PUSH16, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x70FF00112233445566778899AABBCCDDEEFF"
				name: "push17",
				bytecode: MustSplice(PUSH17, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
					0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x71EEFF00112233445566778899AABBCCDDEEFF"
				name: "push18",
				bytecode: MustSplice(PUSH18, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55,
					0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x72DDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push19",
				bytecode: MustSplice(PUSH19, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44,
					0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC,
					0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x73CCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push20",
				bytecode: MustSplice(PUSH20, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33,
					0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB,
					0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x74BBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push21",
				bytecode: MustSplice(PUSH21, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22,
					0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA,
					0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x75AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push22",
				bytecode: MustSplice(PUSH22, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11,
					0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
					0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7699AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push23",
				bytecode: MustSplice(PUSH23, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00,
					0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
					0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push24",
				bytecode: MustSplice(PUSH24, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x78778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push25",
				bytecode: MustSplice(PUSH25, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE,
					0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
					0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7966778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push26",
				bytecode: MustSplice(PUSH26, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD,
					0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
					0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7a5566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push27",
				bytecode: MustSplice(PUSH27, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC,
					0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33, 0x44,
					0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC,
					0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7b445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push28",
				bytecode: MustSplice(PUSH28, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB,
					0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22, 0x33,
					0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB,
					0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7c33445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push29",
				bytecode: MustSplice(PUSH29, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA,
					0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11, 0x22,
					0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA,
					0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7d2233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push30",
				bytecode: MustSplice(PUSH30, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
					0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11,
					0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
					0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x00, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7e112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push31",
				bytecode: MustSplice(PUSH31, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
					0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00,
					0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
					0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7f10112233445566778899AABBCCDDEEFF00112233445566778899AABBCCDDEEFF"
				name: "push32",
				bytecode: MustSplice(PUSH32, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, return1()),
				expected_out: []byte{0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7fff10112233445566778899aabbccddeeff00112233445566778899aabbccddeeff"
				name: "push32_AndSuicide",
				bytecode: MustSplice(PUSH32, 0xFF, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
					0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE,
					0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
					0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, SELFDESTRUCT),
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7fff10112233445566778899aabbccddeeff00112233445566778899aabbccdd"
				name: "push32_FillUpInputWithZerosAtTheEnd",
				bytecode: MustSplice(PUSH32, 0xFF, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
					0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE,
					0xFF, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66,
					0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD),
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7f010203600055"
				name:         "push32_Undefined0",
				bytecode:     MustSplice(PUSH32, 0x01, 0x02, 0x03, 0x60, 0x00, 0x55, return1()),
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7f0102030000000000000000000000000000000000000000000000000000000000"
				name: "push32_Undefined1",
				bytecode: MustSplice(PUSH32, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, return1()),
				expected_out: []byte{0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7f"
				name:         "push32_Undefined2",
				bytecode:     MustSplice(PUSH32, return1()),
				expected_err: errors.Codes.None,
			},
			/*
				{
					// TODO
					// "code": "0x60656107d26204a0c763026921f4640bc5588eb165372d0f1dca6e661ba1d901961c71670c55"
					//		 + "f7bc23038e3868056bc75e2d630fffff69021e19e0c9bab24000016a085d1c6e8050f0ea1c71bd"
					//		 + "6b0688be36543f3c36e638e37a6c03d41f73d55d0d482ae55555376dc76810d0fe03c91964d31c"
					//		 + "71c6f46e615dd0360c07d931663b14e38e38b16f2da3f99955a3adcf27ebb1caaaaaaa6e7014cc"
					//		 + "ba6a8bb1ed35bd86bf065c71c71c2b7109491c5d4781b79c9009de6bfb8e38e38de8720414a0f6"
					//		 + "fdec81304d4c563e740bffffffffa573118427b3b4a05bc8a8a4de8459868000000000017406eb"
					//		 + "15e7331e727940d4ac54b7cdca1c71c71c71bd750567a91c9fefc96ebaa626a22f98c5e638e38e"
					//		 + "38e37a76032abd16c5b68006e15d5aa307e383f4e55555555555377701a6427bdc4f0d58eab5f4"
					//		 + "8a3ec67f64e21c71c71c71c6f478080dd0a0c9b9ff2c2a0c740b06853a0a980ee38e38e38e38b1"
					//		 + "7903c679cb5e8f2f9cb3b5d6652b0e7334f746faaaaaaaaaaaaa6e7a01b873815917ebb2bf3b89"
					//		 + "0a1af495d6235bae3c71c71c71c71c2b7b07ae4cca96e1a55dfa49c85ad3c3e60e426b92fb8e38"
					//		 + "e38e38e38de87c036018bf074e292bcc7d6c8bea0f9699443046178bffffffffffffffa57d0e7d"
					//		 + "34c64a9c85d4460dbbca87196b61618a4bd2168000000000000000017e05b901f48a5b994d6572"
					//		 + "502bc4ea43140486666416aa1c71c71c71c71c71bd7f047889870c178fc477414ea231d70467a3"
					//		 + "88fffe31b4e638e38e38e38e38e37a"
					name: "push33",
					bytecode: MustSplice(),
					expected_err: errors.Codes.None,
				},
			*/
			{
				// "code": "0x7f10112233445566778899aabbccddeeff00112233445566778899aabbccddeeff80"
				name: "dup1",
				bytecode: MustSplice(PUSH32, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, DUP1, return1()),
				expected_out: []byte{0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6002600181"
				name:     "dup2",
				bytecode: MustSplice(PUSH1, 0x02, PUSH1, 0x01, DUP2, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7f10112233445566778899aabbccddeeff00112233445566778899aabbccddeeff81"
				name: "dup2_Error",
				bytecode: MustSplice(PUSH32, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, DUP2, return1()),
				expected_err: errors.Codes.DataStackUnderflow,
			},
			{
				// "code": "0x60036002600182"
				name:     "dup3",
				bytecode: MustSplice(PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP3, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600460036002600183"
				name:     "dup4",
				bytecode: MustSplice(PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP4, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6005600460036002600184"
				name:     "dup5",
				bytecode: MustSplice(PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP5, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60066005600460036002600185"
				name: "dup6",
				bytecode: MustSplice(PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02,
					PUSH1, 0x01, DUP6, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600760066005600460036002600186"
				name: "dup7",
				bytecode: MustSplice(PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03,
					PUSH1, 0x02, PUSH1, 0x01, DUP7, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6008600760066005600460036002600187"
				name: "dup8",
				bytecode: MustSplice(PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04,
					PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP8, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60096008600760066005600460036002600188"
				name: "dup9",
				bytecode: MustSplice(PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05,
					PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP9, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600a6008600760066005600460036002600189"
				name: "dup10",
				bytecode: MustSplice(PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06,
					PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP10, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600b0x600a600860076006600560046003600260018a"
				name: "dup11",
				bytecode: MustSplice(PUSH1, 0x0B, PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07,
					PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP11, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600c600b0x600a600860076006600560046003600260018b"
				name: "dup12",
				bytecode: MustSplice(PUSH1, 0x0C, PUSH1, 0x0B, PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08,
					PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02,
					PUSH1, 0x01, DUP12, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600d600c600b0x600a600860076006600560046003600260018c"
				name: "dup13",
				bytecode: MustSplice(PUSH1, 0x0D, PUSH1, 0x0C, PUSH1, 0x0B, PUSH1, 0x0A, PUSH1, 0x09,
					PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03,
					PUSH1, 0x02, PUSH1, 0x01, DUP13, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600e600d600c600b0x600a600860076006600560046003600260018c"
				name: "dup14",
				bytecode: MustSplice(PUSH1, 0x0E, PUSH1, 0x0D, PUSH1, 0x0C, PUSH1, 0x0B, PUSH1, 0x0A,
					PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04,
					PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP14, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0E},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600f600e600d600c600b0x600a600860076006600560046003600260018c"
				name: "dup15",
				bytecode: MustSplice(PUSH1, 0x0F, PUSH1, 0x0E, PUSH1, 0x0D, PUSH1, 0x0C, PUSH1, 0x0B,
					PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05,
					PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP15, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6010600f600e600d600c600b0x600a600860076006600560046003600260018c"
				name: "dup16",
				bytecode: MustSplice(PUSH1, 0x10, PUSH1, 0x0F, PUSH1, 0x0E, PUSH1, 0x0D, PUSH1, 0x0C,
					PUSH1, 0x0B, PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06,
					PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, DUP16, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},
				expected_err: errors.Codes.None,
			},
		}
		for _, tt := range tests {
			params := engine.CallParams{
				Caller: account1,
				Callee: account2,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_err, errors.GetCode(err))
			} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_out, output)
			}
		}
	})

	t.Run("Swap tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 100000

		tests := []struct {
			name         string
			bytecode     []byte
			expected_out []byte
			expected_err *errors.Code
		}{
			{
				// "code": "0x7f10112233445566778899aabbccddeeff00112233445566778899aabbccddeeff60039055"
				name: "swap1",
				bytecode: MustSplice(PUSH32, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, PUSH1, 0x03, SWAP1, SSTORE,
					PUSH32, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6002600160039155"
				name: "swap2",
				bytecode: MustSplice(PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP2, SSTORE,
					PUSH1, 0x02, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x7f10112233445566778899aabbccddeeff00112233445566778899aabbccddeeff60039155"
				name: "swap2_Error",
				bytecode: MustSplice(PUSH32, 0x10, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF,
					0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
					0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, PUSH1, 0x03, SWAP2, SSTORE),
				expected_err: errors.Codes.DataStackUnderflow,
			},
			{
				// "code": "0x60036002600160039255"
				name: "swap3",
				bytecode: MustSplice(PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP3, SSTORE,
					PUSH1, 0x03, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600460036002600160039355"
				name: "swap4",
				bytecode: MustSplice(PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP4, SSTORE,
					PUSH1, 0x04, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6005600460036002600160039455"
				name: "swap5",
				bytecode: MustSplice(PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01,
					PUSH1, 0x03, SWAP5, SSTORE, PUSH1, 0x05, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60066005600460036002600160039555"
				name: "swap6",
				bytecode: MustSplice(PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02,
					PUSH1, 0x01, PUSH1, 0x03, SWAP6, SSTORE, PUSH1, 0x06, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600760066005600460036002600160039655"
				name: "swap7",
				bytecode: MustSplice(PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03,
					PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP7, SSTORE, PUSH1, 0x07, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6008600760066005600460036002600160039755"
				name: "swap8",
				bytecode: MustSplice(PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04,
					PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP8, SSTORE, PUSH1, 0x08, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60096008600760066005600460036002600160039855"
				name: "swap9",
				bytecode: MustSplice(PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05,
					PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP9, SSTORE,
					PUSH1, 0x09, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600a60096008600760066005600460036002600160039955"
				name: "swap10",
				bytecode: MustSplice(PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06,
					PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP10, SSTORE,
					PUSH1, 0x0A, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600b600a60096008600760066005600460036002600160039a55"
				name: "swap11",
				bytecode: MustSplice(PUSH1, 0x0B, PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07,
					PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01,
					PUSH1, 0x03, SWAP11, SSTORE, PUSH1, 0x0B, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600c600b600a60096008600760066005600460036002600160039b55"
				name: "swap12",
				bytecode: MustSplice(PUSH1, 0x0C, PUSH1, 0x0B, PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08,
					PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02,
					PUSH1, 0x01, PUSH1, 0x03, SWAP12, SSTORE, PUSH1, 0x0C, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600d600c600b600a60096008600760066005600460036002600160039c55"
				name: "swap13",
				bytecode: MustSplice(PUSH1, 0x0D, PUSH1, 0x0C, PUSH1, 0x0B, PUSH1, 0x0A, PUSH1, 0x09,
					PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03,
					PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP13, SSTORE, PUSH1, 0x0D, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600e600d600c600b600a60096008600760066005600460036002600160039d55"
				name: "swap14",
				bytecode: MustSplice(PUSH1, 0x0E, PUSH1, 0x0D, PUSH1, 0x0C, PUSH1, 0x0B, PUSH1, 0x0A,
					PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05, PUSH1, 0x04,
					PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP14, SSTORE,
					PUSH1, 0x0E, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600f600e600d600c600b600a60096008600760066005600460036002600160039e55"
				name: "swap15",
				bytecode: MustSplice(PUSH1, 0x0F, PUSH1, 0x0E, PUSH1, 0x0D, PUSH1, 0x0C, PUSH1, 0x0B,
					PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06, PUSH1, 0x05,
					PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03, SWAP15, SSTORE,
					PUSH1, 0x0F, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6010600f600e600d600c600b600a60096008600760066005600460036002600160039f55"
				name: "swap16",
				bytecode: MustSplice(PUSH1, 0x10, PUSH1, 0x0F, PUSH1, 0x0E, PUSH1, 0x0D, PUSH1, 0x0C,
					PUSH1, 0x0B, PUSH1, 0x0A, PUSH1, 0x09, PUSH1, 0x08, PUSH1, 0x07, PUSH1, 0x06,
					PUSH1, 0x05, PUSH1, 0x04, PUSH1, 0x03, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x03,
					SWAP16, SSTORE, PUSH1, 0x10, SLOAD, return1()),
				expected_out: []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600560026001600c575050005b9060016116575050005b035b0360005260016003611ff3"
				name: "swap_jump",
				bytecode: MustSplice(PUSH1, 0x05, PUSH1, 0x02, PUSH1, 0x01, PUSH1, 0x0C, JUMPI, POP, POP,
					0x00, JUMPDEST, SWAP1, PUSH1, 0x01, PUSH2, 0x16, 0x57, POP, POP,
					0x00, JUMPDEST, SUB, JUMPDEST, SUB, PUSH1, 0x00, MSTORE,
					PUSH1, 0x01, PUSH1, 0x03, PUSH2, 0x1F, 0xF3, return1()),
				expected_err: errors.Codes.None,
			},
		}
		for _, tt := range tests {
			params := engine.CallParams{
				Caller: account1,
				Callee: account2,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_err, errors.GetCode(err))
			} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_out, output)
			}
		}
	})

	t.Run("Sha3 tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 10000000000

		tests := []struct {
			name         string
			origin       crypto.Address
			input        []byte
			value        uint64
			bytecode     []byte
			expected_out []byte
			expected_err *errors.Code
		}{
			{
				// "code": "0x6000600020"
				name:     "sha3_0",
				bytecode: MustSplice(PUSH1, 0x00, PUSH1, 0x00, SHA3, return1()),
				expected_out: []byte{0xC5, 0xD2, 0x46, 0x01, 0x86, 0xF7, 0x23, 0x3C,
					0x92, 0x7E, 0x7D, 0xB2, 0xDC, 0xC7, 0x03, 0xC0,
					0xE5, 0x00, 0xB6, 0x53, 0xCA, 0x82, 0x27, 0x3B,
					0x7B, 0xFA, 0xD8, 0x04, 0x5D, 0x85, 0xA4, 0x70},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x6005600420"
				name:     "sha3_1",
				bytecode: MustSplice(PUSH1, 0x05, PUSH1, 0x04, SHA3, return1()),
				expected_out: []byte{0xC4, 0x15, 0x89, 0xE7, 0x55, 0x98, 0x04, 0xEA,
					0x4A, 0x20, 0x80, 0xDA, 0xD1, 0x9D, 0x87, 0x6A,
					0x02, 0x4C, 0xCB, 0x05, 0x11, 0x78, 0x35, 0x44,
					0x7D, 0x72, 0xCE, 0x08, 0xC1, 0xD0, 0x20, 0xEC},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600a600a20"
				name:     "sha3_2",
				bytecode: MustSplice(PUSH1, 0x0A, PUSH1, 0x0A, SHA3, return1()),
				expected_out: []byte{0x6B, 0xD2, 0xDD, 0x6B, 0xD4, 0x08, 0xCB, 0xEE,
					0x33, 0x42, 0x93, 0x58, 0xBF, 0x24, 0xFD, 0xC6,
					0x46, 0x12, 0xFB, 0xF8, 0xB1, 0xB4, 0xDB, 0x60,
					0x45, 0x18, 0xF4, 0x0F, 0xFD, 0x34, 0xB6, 0x07},
				expected_err: errors.Codes.None,
			},
			/*
				{
					// TODO
					// "code": "0x6002630100000020"
					name: "sha3_BigOffset",
					bytecode: MustSplice(PUSH1, 0x02, PUSH4, 0x01, 0x00, 0x00, 0x00, SHA3, return1()),
					expected_out: []byte{0x54, 0xA8, 0xC0, 0xAB, 0x65, 0x3C, 0x15, 0xBF,
						0xB4, 0x8B, 0x47, 0xFD, 0x01, 0x1B, 0xA2, 0xB9,
						0x61, 0x7A, 0xF0, 0x1C, 0xB4, 0x5C, 0xAB, 0x34,
						0x4A, 0xCD, 0x57, 0xC9, 0x24, 0xD5, 0x67, 0x98},
					expected_err: errors.Codes.None,
				},
			*/
			{
				// "code": "0x60016103c020"
				name:     "sha3_MemSizeNoQuadraticCost31",
				bytecode: MustSplice(PUSH1, 0x01, PUSH2, 0x03, 0xC0, SHA3, return1()),
				expected_out: []byte{0xBC, 0x36, 0x78, 0x9E, 0x7A, 0x1E, 0x28, 0x14,
					0x36, 0x46, 0x42, 0x29, 0x82, 0x8F, 0x81, 0x7D,
					0x66, 0x12, 0xF7, 0xB4, 0x77, 0xD6, 0x65, 0x91,
					0xFF, 0x96, 0xA9, 0xE0, 0x64, 0xBC, 0xC9, 0x8A},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60016103e020"
				name:     "sha3_MemSizeNoQuadraticCost32",
				bytecode: MustSplice(PUSH1, 0x01, PUSH2, 0x03, 0xE0, SHA3, return1()),
				expected_out: []byte{0xBC, 0x36, 0x78, 0x9E, 0x7A, 0x1E, 0x28, 0x14,
					0x36, 0x46, 0x42, 0x29, 0x82, 0x8F, 0x81, 0x7D,
					0x66, 0x12, 0xF7, 0xB4, 0x77, 0xD6, 0x65, 0x91,
					0xFF, 0x96, 0xA9, 0xE0, 0x64, 0xBC, 0xC9, 0x8A},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600061040020"
				name:     "sha3_MemSizeNoQuadraticCost32_ZeroSize",
				bytecode: MustSplice(PUSH1, 0x00, PUSH2, 0x04, 0x00, SHA3, return1()),
				expected_out: []byte{0xC5, 0xD2, 0x46, 0x01, 0x86, 0xF7, 0x23, 0x3C,
					0x92, 0x7E, 0x7D, 0xB2, 0xDC, 0xC7, 0x03, 0xC0,
					0xE5, 0x00, 0xB6, 0x53, 0xCA, 0x82, 0x27, 0x3B,
					0x7B, 0xFA, 0xD8, 0x04, 0x5D, 0x85, 0xA4, 0x70},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x600161040020"
				name:     "sha3_MemSizeNoQuadraticCost33",
				bytecode: MustSplice(PUSH1, 0x01, PUSH2, 0x04, 0x00, SHA3, return1()),
				expected_out: []byte{0xBC, 0x36, 0x78, 0x9E, 0x7A, 0x1E, 0x28, 0x14,
					0x36, 0x46, 0x42, 0x29, 0x82, 0x8F, 0x81, 0x7D,
					0x66, 0x12, 0xF7, 0xB4, 0x77, 0xD6, 0x65, 0x91,
					0xFF, 0x96, 0xA9, 0xE0, 0x64, 0xBC, 0xC9, 0x8A},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x60206107e020"
				name:     "sha3_MemSizeNoQuadraticCost64",
				bytecode: MustSplice(PUSH1, 0x20, PUSH2, 0x07, 0xE0, SHA3, return1()),
				expected_out: []byte{0x29, 0x0D, 0xEC, 0xD9, 0x54, 0x8B, 0x62, 0xA8,
					0xD6, 0x03, 0x45, 0xA9, 0x88, 0x38, 0x6F, 0xC8,
					0x4B, 0xA6, 0xBC, 0x95, 0x48, 0x40, 0x08, 0xF6,
					0x36, 0x2F, 0x93, 0x16, 0x0E, 0xF3, 0xE5, 0x63},
				expected_err: errors.Codes.None,
			},
		}
		for _, tt := range tests {
			value := big.NewInt(int64(tt.value))
			params := engine.CallParams{
				Origin: tt.origin,
				Caller: account1,
				Callee: account2,
				Input:  tt.input,
				Value:  *value,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_err, errors.GetCode(err))
			} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_out, output)
			}
		}
	})

	t.Run("System operations tests", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 100000

		tests := []struct {
			name         string
			origin       crypto.Address
			input        []byte
			value        uint64
			bytecode     []byte
			expected_out []byte
			expected_err *errors.Code
		}{
			{
				// "code": "0x6000355415600957005b60203560003555"
				name: "TestNameRegistrator",
				input: []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFA,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFA},
				bytecode: MustSplice(PUSH1, 0x00, CALLDATALOAD, SLOAD, ISZERO, PUSH1, 0x09, JUMPI,
					0x00, JUMPDEST, PUSH1, 0x20, CALLDATALOAD, PUSH1, 0x00, CALLDATALOAD, SSTORE,
					PUSH1, 0x00, CALLDATALOAD, SLOAD, return1()),
				expected_out: []byte{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
					0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFA},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x603760005360005160005560016000f3"
				name: "return0",
				bytecode: MustSplice(PUSH1, 0x37, PUSH1, 0x00, MSTORE8, PUSH1, 0x00, MLOAD,
					PUSH1, 0x00, SSTORE, PUSH1, 0x01, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x37},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x603760005360005160005560026000f3"
				name: "return1",
				bytecode: MustSplice(PUSH1, 0x37, PUSH1, 0x00, MSTORE8, PUSH1, 0x00, MLOAD,
					PUSH1, 0x00, SSTORE, PUSH1, 0x02, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x37, 0x00},
				expected_err: errors.Codes.None,
			},
			{
				// "code": "0x603760005360005160005560216000f3"
				name: "return2",
				bytecode: MustSplice(PUSH1, 0x37, PUSH1, 0x00, MSTORE8, PUSH1, 0x00, MLOAD,
					PUSH1, 0x00, SSTORE, PUSH1, 0x21, PUSH1, 0x00, RETURN),
				expected_out: []byte{0x37, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
					0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
				expected_err: errors.Codes.None,
			},
		}
		for _, tt := range tests {
			value := big.NewInt(int64(tt.value))
			params := engine.CallParams{
				Origin: tt.origin,
				Caller: account1,
				Callee: account2,
				Input:  tt.input,
				Value:  *value,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_err, errors.GetCode(err))
			} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_out, output)
			}
		}
	})

	t.Run("Suicide test", func(t *testing.T) {
		st := acmstate.NewMemoryState()
		blockchain := new(blockchain)
		eventSink := exec.NewNoopEventSink()

		account1 := newAccount(t, st, "1")
		account2 := newAccount(t, st, "101")
		var gas uint64 = 100000

		tests := []struct {
			name         string
			bytecode     []byte
			expected_out []byte
			expected_err *errors.Code
		}{
			{
				name:         "suicide",
				bytecode:     MustSplice(CALLER, SELFDESTRUCT, return1()),
				expected_out: nil,
				expected_err: errors.Codes.None,
			},
		}
		for _, tt := range tests {
			params := engine.CallParams{
				Caller: account1,
				Callee: account2,
				Gas:    big.NewInt(int64(gas)),
			}
			if output, err := vm.Execute(st, blockchain, eventSink, params, tt.bytecode); errors.GetCode(err) != tt.expected_err {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_err, errors.GetCode(err))
			} else if tt.expected_err == errors.Codes.None && !bytes.Equal(output, tt.expected_out) {
				t.Errorf("FAIL: %v.", tt.name)
				assert.Equal(t, tt.expected_out, output)
			}
		}
	})
}

type blockchain struct {
	blockHeight uint64
	blockTime   time.Time
	chainid     string
}

func (b *blockchain) LastBlockHeight() uint64 {
	return b.blockHeight
}

func (b *blockchain) LastBlockTime() time.Time {
	return b.blockTime
}

func (b *blockchain) BlockHash(height uint64) ([]byte, error) {
	if height > b.blockHeight {
		return nil, errors.Codes.InvalidBlockNumber
	}
	bs := make([]byte, 32)
	binary.BigEndian.PutUint64(bs[24:], height)
	return bs, nil
}

func (b *blockchain) ChainID() string {
	return b.chainid
}

// helpers

func newAccount(t testing.TB, st acmstate.ReaderWriter, name string) crypto.Address {
	address := engine.AddressFromName(name)
	err := engine.CreateAccount(st, address)
	require.NoError(t, err)
	return address
}

func makeAccountWithCode(t testing.TB, st acmstate.ReaderWriter, name string, code []byte) crypto.Address {
	address := engine.AddressFromName(name)
	err := engine.CreateAccount(st, address)
	require.NoError(t, err)
	err = engine.InitEVMCode(st, address, code)
	require.NoError(t, err)
	addToBalance(t, st, address, 9999999)
	return address
}

func addToBalance(t testing.TB, st acmstate.ReaderWriter, address crypto.Address, amount uint64) {
	err := engine.UpdateAccount(st, address, func(account *acm.Account) error {
		return account.AddToBalance(amount)
	})
	require.NoError(t, err)
}

func call(vm *CVM, st acmstate.ReaderWriter, origin, callee crypto.Address, code []byte, input []byte,
	gas *uint64) ([]byte, error) {

	evs := new(exec.Events)
	out, err := vm.Execute(st, new(blockchain), evs, engine.CallParams{
		Caller: origin,
		Callee: callee,
		Input:  input,
		Gas:    big.NewInt(int64(*gas)),
	}, code)

	if err != nil {
		return nil, &errors.CallError{
			CodedError:   errors.AsException(err),
			NestedErrors: evs.NestedCallErrors(),
		}
	}
	return out, nil
}

// These code segment helpers exercise the MSTORE MLOAD MSTORE cycle to test
// both of the memory operations. Each MSTORE is done on the memory boundary
// (at MSIZE) which Solidity uses to find guaranteed unallocated memory.

// storeAtEnd expects the value to be stored to be on top of the stack, it then
// stores that value at the current memory boundary
func storeAtEnd() []byte {
	// Pull in MSIZE (to carry forward to MLOAD), swap in value to store, store it at MSIZE
	return MustSplice(MSIZE, SWAP1, DUP2, MSTORE)
}

func returnAfterStore() []byte {
	return MustSplice(PUSH1, 32, DUP2, RETURN)
}

// Store the top element of the stack (which is a 32-byte word) in memory
// and return it. Useful for a simple return value.
func return1() []byte {
	return MustSplice(PUSH1, 0, MSTORE, returnWord())
}

func returnWord() []byte {
	// PUSH1 => return size, PUSH1 => return offset, RETURN
	return MustSplice(PUSH1, 32, PUSH1, 0, RETURN)
}

// Subscribes to an AccCall, runs the vm, returns the output any direct exception
// and then waits for any exceptions transmitted by Data in the AccCall
// event (in the case of no direct error from call we will block waiting for
// at least 1 AccCall event)
func runVM(st acmstate.ReaderWriter, caller, callee crypto.Address, code []byte, gas uint64) *exec.TxExecution {
	gasBefore := gas
	txe := new(exec.TxExecution)
	vm := NewCVM(engine.Options{
		DebugOpcodes: true,
	})
	params := engine.CallParams{
		Caller: caller,
		Callee: callee,
		Gas:    big.NewInt(int64(gas)),
	}
	output, err := vm.Execute(st, new(blockchain), txe, params, code)
	txe.PushError(err)
	for _, ev := range txe.ExceptionalCalls() {
		txe.PushError(ev.Header.Exception)
	}
	txe.Return(output, gasBefore-gas)
	return txe
}

// this is code to call another contract (hardcoded as addr)
func callContractCode(addr crypto.Address) []byte {
	gas1, gas2 := byte(0xff) /*byte(0x1)*/, byte(0x1)
	value := byte(0x69)
	inOff, inSize := byte(0x0), byte(0x0) // no call data
	retOff, retSize := byte(0x0), byte(0x20)
	// this is the code we want to run (send funds to an account and return)
	return MustSplice(PUSH1, retSize, PUSH1, retOff, PUSH1, inSize, PUSH1,
		inOff, PUSH1, value, PUSH20, addr, PUSH2, gas1, gas2, CALL, PUSH1, retSize,
		PUSH1, retOff, RETURN)
}

// Produce bytecode for a PUSH<N>, b_1, ..., b_N where the N is number of bytes
// contained in the unpadded word
func pushWord(word Word256) []byte {
	leadingZeros := byte(0)
	for leadingZeros < 32 {
		if word[leadingZeros] == 0 {
			leadingZeros++
		} else {
			return MustSplice(byte(PUSH32)-leadingZeros, word[leadingZeros:])
		}
	}
	return MustSplice(PUSH1, 0)
}
